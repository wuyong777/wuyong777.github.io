{"面试题.html":{"url":"面试题.html","title":"面试题","keywords":"","body":"面试流程 1、筛选规则 2、简历注意事项 3、项目美化 4、面试过程... Redis 1、缓存-缓存穿透 缓存穿透是指查询的数据在数据库中也不存在，因此不会被写入缓存，下次同样的查询请求还是会直接发送到数据库，这就导致了缓存形同虚设，大量的请求直接对数据库产生压力，甚至可能导致数据库崩溃。针对这个问题，常用的解决方案包括： 使用布隆过滤器：即使数据不存在，也将其“可能存在”的哈希值放入布隆过滤器中，当查询请求来临时，先经过布隆过滤器验证，若确认一定不存在，则不再查询数据库。 对空结果进行缓存：对于数据库查询结果为空的情况，也可以在缓存中设置一个特殊的标记，比如设置一个特定的key-value（key对应查询条件，value为特殊标记或空对象），并给这个缓存设置一个较短的有效期，这样可以在一段时间内阻止同样的请求再次穿透到数据库。 2、缓存-缓存击穿 缓存击穿是指热点数据在缓存过期的瞬间，同时有大量的并发请求过来，所有的请求都集中到了数据库，对数据库造成了巨大的压力。针对缓存击穿问题，可以采取如下措施： 加互斥锁（Mutex Key）：对热点数据的缓存加锁，保证同一时间只有一个请求能去数据库获取数据，其他请求等待解锁后从缓存中获取。 设置热点数据永不过期：对于极有可能引发缓存击穿的热点数据，可以设计为永不过期或者定期刷新，而不是依赖固定过期时间。 3、缓存-缓存雪崩 缓存雪崩是指缓存服务大面积、大量地失效，导致所有请求直接落到数据库，使得数据库瞬间压力剧增，可能会导致整个系统崩溃。常见场景如缓存服务器整体宕机或大批量缓存同时过期。防范缓存雪崩的方法有： 分布式缓存：使用集群部署，单个节点故障不会影响整个缓存服务。 数据预热：在缓存失效前，提前对即将过期的数据进行重新加载，使得新数据已经在缓存中待命。 熔断降级：当检测到数据库压力过大时，可以通过熔断机制暂时停止写入缓存或者返回默认值，保护数据库不受冲击。 合理设置缓存过期时间：避免大量缓存在同一时刻失效，可以随机设置过期时间，或者设置TTL的同时配合TTI（Time To Idle，空闲过期时间）策略。 4、缓存-双写一致性 双写一致性指的是在使用缓存与数据库结合的架构中，保证缓存和数据库中的数据始终保持一致的过程。在进行写操作时，不仅要更新数据库，还需要更新缓存，以确保后续读请求从缓存获取到的是最新数据。主要挑战在于如何避免数据的不一致性和并发问题。常见的解决策略包括： 先更新数据库再删除缓存：可能出现短暂窗口期内的读请求直接访问数据库的问题，需要考虑并发控制（如分布式锁）。 先更新数据库再更新缓存：如果缓存更新失败，需有补偿机制确保数据最终一致性。 使用队列异步更新：将写请求放入消息队列，异步地依次更新数据库和缓存。 5、缓存-持久化 持久化是指将缓存中的数据保存到磁盘上，以防止服务器重启或意外宕机造成的缓存数据丢失。在Redis中，持久化主要有两种方式： RDB（Redis DataBase）：周期性地将内存中的数据生成快照dump到磁盘上。 AOF（Append Only File）：记录每一个写命令，以追加的形式保存在硬盘上，重启时按顺序执行AOF文件中的命令来恢复数据。 6、缓存-数据过期策略 缓存数据过期策略是指设定缓存数据的有效期限，超过期限的数据将被自动清除或标记为无效。常见的过期策略有： 绝对过期：设置固定的过期时间，超过该时间后缓存失效。 滑动过期：基于最后一次访问时间来动态延长缓存有效期。 TTL（Time to Live）：为缓存项设置生存时间。 TTI（Time to Idle）：空闲时间过期，如果在规定时间内缓存项未被访问则失效。 7、缓存-数据淘汰策略 当缓存空间不足时，需要根据某种策略淘汰旧数据以便存放新数据。常见的淘汰策略包括： LRU（Least Recently Used）：最近最少使用，优先淘汰最近最少访问过的数据。 LFU（Least Frequently Used）：最不经常使用，优先淘汰访问频率最低的数据。 FIFO（First In First Out）：先进先出，最先存入的数据最先被淘汰。 8、分布式锁-使用场景 分布式锁用于多进程或分布式环境下，解决共享资源的互斥访问问题，例如： 控制分布式系统中资源的并发访问，防止竞态条件和死锁。 实现全局唯一ID的生成。 在微服务架构中，确保跨服务的幂等操作只执行一次。 9、分布式锁-实现原理（setnx,redisson） SETNX（Set if Not Exists）是Redis命令，用于原子地设置键值对，仅当键不存在时设置成功，可以作为简单的分布式锁实现方式。 Redisson是一个Redis客户端，提供了更丰富的分布式锁功能，如可重入锁、公平锁、读写锁等。它通过在Redis中创建具有超时的lua脚本实现锁的获取和释放，确保锁的原子性和安全性。 10、其他-主从复制，主从同步流程 主从复制是Redis高可用和数据备份的重要手段，主节点将数据更改同步给从节点。 主从同步流程通常包括： 初始同步：从节点连上主节点后，从节点进行全量复制，拉取主节点的RDB文件或所有增量命令。 增量同步：初始同步完成后，主节点接收到写命令后，将写命令发送给从节点，从节点接收并执行命令。 11、其他-哨兵模式，集群脑裂 哨兵模式是Redis的高可用解决方案，哨兵节点监控主从集群，自动处理主节点故障转移。 集群脑裂（Split-Brain）是指在部分节点失去联系的情况下，原本的集群分裂成两个或多个互相独立的部分，各自选举出自己的主节点，从而导致数据不一致。哨兵模式通过配置适当的投票规则和配置参数来尽量避免脑裂的发生。 12、其他-分片集群，数据读写规则 Redis Cluster实现了数据分片（sharding），将数据分散存储在多个Redis节点上，每个节点负责存储一部分数据。 数据读写规则： 写操作：客户端根据Key的CRC16哈希值确定所属槽（slot），并将数据写入对应的主节点。 读操作：客户端可以直接从负责该Key的主节点或从节点读取数据。 13、其他-redis是单线程的，但是为什么快还那么快 Redis之所以能在单线程模型下依然保持高性能的原因： 完全基于内存操作，避免了磁盘IO带来的延迟。 单线程避免了线程切换带来的开销，CPU Cache局部性原理使得单线程性能优异。 数据结构简单且高效，Redis使用了多种复杂度较低的数据结构，如哈希表、跳跃表、整数集合等。 使用I/O多路复用技术（如epoll/kqueue），在一个线程内监听多个socket连接，高效地处理并发连接请求。 MySQL 1、优化-如何定位慢查询 2、优化-sql执行的很慢，如何分析 3、优化-索引概念及索引底层数据结构 4、优化-聚簇索引和非聚簇索引，回表查询 5、优化-索引覆盖，超大分页优化 6、优化-索引创建的原则 7、优化-什么情况下索引会失效 8、优化-谈一谈你对sql优化的经验 9、事务-事务的特性 10、事务-并发事务问题，隔离级别 11、事务-undo log和redo log的区别 12、事务-解释一下mvcc 13、主从同步原理 14、分库分表 框架篇 1、Spring-单例bean是线程安全的吗 2、Spring-AOP相关面试题 3、Spring-事务失效的场景 4、Spring-bean的生命周期 5、Spring-bean的循环依赖（循环引用） 6、SpringMVC-执行流程 7、SpringBoot-自动配置原理 8、Spring框架-常见注解（Spring，SpringMVC，SpringBoot） 9、MyBatis-执行流程 10、MyBatis-延迟加载使用及原理 11、MyBatis-一级，二级缓存 微服务篇 1、springCloud-常见组件有哪些 2、springCloud-注册中心Eureka，Nacos 3、springCloud-Ribbon负载均衡，负载均衡策略，自定义负载均衡 4、springCloud-服务雪崩，熔断限流 5、springCloud-微服务的监控-skywalking 6、业务问题-微服务的限流（漏桶算法，令牌桶算法） 7、分布式系统理论-CAP和BASE 8、业务问题-分布式事务解决方案 9、业务问题-分布式服务的接口幂等性如何设计 10、业务问题-你们项目中使用什么分布式任务调度xxl-job 消息中间件篇 1、RabbitMQ-如何保证消息不丢失 2、RabbitMQ-消息的重复消费问题如何解决的 3、RabbitMQ-中死性交换机（RabbitMQ延迟队列有了解过吗） 4、RabbitMQ-如果有100万消息堆积在MQ，如何解决（消息堆积怎么解决） 5、RabbitMQ-高可用机制有了解过吗 6、Kafka-如何保证消息不丢失 7、Kafka-如何保证消费的顺序性 8、Kafka-高可用机制有了解过吗 9、Kafka-数据清理机制了解过吗 10、Kafka-实现高性用的设计有了解过吗 Java 集合 1、算法复杂度分析 2、ArrayList-数据结构-数组 3、ArrayList-源码分析 4、ArrayList-底层原理及构造函数相关面试题回答 5、ArrayList-如何实现数组和List的转换 6、LinkedList-数据结构-链表 7、ArrayList和LinkedList的区别是什么 8、数据结构-二叉树 9、数据结构-红黑树 10、数据结构-散列表 11、HashMap-说一下HashMap的实现原理 12、HashMap-put方法的具体流程 13、HashMap-讲一讲HashMap的扩容机制 14、HashMap-源码分析 15、HashMap-寻址算法和数组长度为什么是2的n次幂 16、HashMap-在1.7情况下多线程死循环问题 Java 并发 1、线程基础-线程与进程的区别 2、线程基础-并行与并发的区别 3、线程基础-线程创建的方式，runable和callable的区别，start和run的区别 4、线程基础-线程包括哪些状态，状态之间是如何变化的 5、线程基础-线程按顺序执行join，notify，notifyall的区别 6、线程基础-Java中wait和sleep方法的不同 7、线程基础-如何停止一个正在运行的线程 8、线程安全-synchronized关键字的底层原理-基础回答 9、线程安全-synchronized关键字的底层原理-进阶回答 10、线程安全-你谈谈JMM（Java内存模型） 11、线程安全-你谈谈对CAS的理解 12、线程安全-请谈谈你对volatile的理解-可见性 13、线程安全-请谈谈你对volatile-禁止指令重排序 14、线程安全-什么是AQS 15、线程安全-ReenrantLock的实现原理 16、线程安全-synchrnized和Lock的区别 17、线程安全-死锁产生的条件以及死锁排查方案 18、线程安全-聊一下ConcurrentHashMap 19、线程安全-导致并发程序出现问题的根本原因是什么 20、线程池-说一下线程池的核心参数（线程池的执行原理知道吗） 21、线程池-线程池中有哪些常见的阻塞队列 22、线程池-如何确定核心线程数 23、线程池-线程池的种类有哪些 24、线程池-为什么不建议用Excutors创建线程池 25、使用场景-线程池的使用场景（你们项目哪里使用到了多线程）-ES数据批量导入 26、使用场景-线程池的使用场景（你们项目哪里使用到了多线程）-数据汇总 27、使用场景-线程池的使用场景（你们项目哪里使用到了多线程）-异步线程 28、使用场景-如何控制某个方法允许并发访问线程数量 29、其他-谈谈你对ThreadLocal的理解 JVM 1、JVM介绍，运行流程 2、JVM组成-什么是程序计数器 3、JVM组成-你能给我详细介绍下堆吗 4、JVM组成-什么是虚拟机栈 5、JVM组成-能不能介绍一下方法区 6、JVM组成-你听过直接内存吗 7、类加载器-什么是类加载器，什么是双亲委派机制 8、类加载器-说一下类装载的执行过程 9、垃圾回收-对象什么时候被垃圾器回收 10、垃圾回收-JVM垃圾回收算法有哪些 11、垃圾回收-说一下JVM的分代回收 12、垃圾回收-说一下JVM有哪些垃圾回收器 13、垃圾回收-详细聊一下G1垃圾回收器 14、垃圾回收-强引用，软引用，弱引用，虚引用的区别 15、JVM实践-JVM调优参数可以在哪里设置参数值 16、JVM实践-用的JVM调优的参数有哪些 17、JVM实践-说一下JVM调优的工具 18、JVM实践-Java内存泄漏的排查思路 19、JVM实践-CPU飙高的排查方案和思路 设计模式 1、工厂设计模式-简单工厂 2、工厂设计模式-工厂方法 3、工厂设计模式-抽象工厂 4、策略模式-概述及简单案例 5、综合案例-策略模式和工厂方法 6、责任链模式-概述及简单案例 技术场景 1、单点登录怎么实现的 2、权限认证如何实现的 3、上传数据的安全性你们怎么控制 4、遇到了哪些比较棘手的问题，怎么解决的 5、项目中日志怎么采集的 6、常见的日志命令 7、生产问题怎么排查 8、怎么快速定位系统的瓶颈 其他 1、Java常见bug,异常 Java编程中常见的Bug和异常包括但不限于以下几种： NullPointerException (NPE)： 这是最常见的异常之一，发生在试图访问或操作一个尚未初始化（即值为null）的对象引用时。例如，如果你声明了一个对象但没有实例化它，然后试图调用其方法或访问其字段，将会抛出此异常。 ArrayIndexOutOfBoundsException： 当尝试访问数组的一个不存在的位置，即索引超出数组界限时，会抛出此异常。例如，如果你对一个长度为5的数组使用了大于等于5的索引值。 ClassCastException： 在强制类型转换不合法的情况下发生，即试图将一个对象转换成非兼容类型的对象时抛出此异常。 NumberFormatException： 当试图将字符串转换为数值类型（如Integer、Double等），而该字符串不能被正确解析为相应数值时抛出。 FileNotFoundException： 在尝试打开一个不存在的文件或路径时，FileInputStream、FileReader等类的操作会抛出此异常。 IOException： 当与输入/输出操作相关的错误发生时，例如读写文件、网络通信失败等，都会抛出此类及其子类异常。 ArithmeticException： 在执行非法的数学运算时，如除数为零，会抛出此异常。 StackOverflowError： 当递归调用过深或者递归循环没有正确终止条件导致栈空间耗尽时，系统抛出此错误。 OutOfMemoryError： JVM无法分配足够的内存来完成一个对象的创建或其他内存操作时，会抛出此错误。这可能是因为堆内存不足或者持久代内存溢出。 ClassNotFoundException： 在运行时动态加载类时，如果找不到指定名称的类，会抛出此异常，通常出现在反射API使用不当或者所需的类库未被正确引入到classpath中。 以上都是Java编程中常见的错误类型，它们大多属于Java异常体系的一部分，并且都可以通过try-catch-finally语句结构来进行捕获和处理。对于开发者而言，理解和熟练处理这些异常是编写健壮程序的关键。 引用 新版Java面试专题视频教程，java八股文面试全套真题+深度详解（含大厂高频面试真题）https://www.bilibili.com/video/BV1yT411H7YK 注意：21和23重叠的部分多，21可以直接pass掉。此外，只看完这个是肯定不够的，还是得多背背八股文，多看看面经，刷题（SQL和算法都不能落下） Java面试宝典 https://blog.csdn.net/qq_48592827/category_12431582.html Next 阅读指南 "},"./":{"url":"./","title":"阅读指南","keywords":"","body":"阅读指南 进程、线程、协程、同步、异步、阻塞、非阻塞、并发、并行、串行 进程： 进程是操作系统中资源分配和调度的基本单位，代表着系统中运行的一个程序实例。 每个进程都有独立的内存空间和其他系统资源。 不同的进程之间相互隔离，通过进程间通信（IPC）机制进行信息交互。 线程： 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程内部的一个独立执行流。 一个进程中可以包含多个线程。这些线程共享进程的内存空间和其他资源，因此创建和切换线程的开销小于进程。 多线程可以实现进程内部的并发执行，提高CPU利用率。 协程： 协程是一种用户态的轻量级线程实现，也称作协作式多任务。 它不同于操作系统调度的线程，协程的调度完全由用户程序控制。 协程可以在函数调用时保存上下文并在适当时候恢复执行，允许在单个线程中模拟出多任务效果，且没有线程切换的开销。 同步： 同步指的是一个操作完成后才会执行下一个操作。 比如在编程中调用一个函数，直到该函数返回结果后，后续代码才会继续执行。 同步执行不会立即返回控制权，而是等待任务完成。 异步： 异步则是指发起一个操作后，无需等待该操作完成即可继续执行后续代码。 操作结果通过回调，或者通过事件等机制通知调用者。 这种模式下，程序不会阻塞等待某个操作结束，即调用发出后不必等待响应就可以去做别的事情。 阻塞： 阻塞是指在执行某个操作（如I/O请求）时，调用线程或进程会暂停执行，直到该操作完成。 在此期间，操作系统可能将CPU时间片分配给其他可执行的线程或进程。 非阻塞： 非阻塞操作则是指调用发出后，调用者不会被挂起，而是立即返回一个状态（如“未准备好”）。 然后调用者可以选择轮询检查操作是否完成，或者通过事件通知机制得知操作完成。 并发： 并发是指在一段时间内多个任务交替执行，从宏观上看似乎同时发生，但实际上由于CPU时间片轮转，微观上并非真正的同时执行。 并发强调的是多个任务在执行时间上的重叠。 并行： 并行指两个或多个任务在同一时刻真正地同时执行，尤其在多核或多处理器环境中，每个核心可以独立执行任务，实现物理上的同时处理。 并行强调的是在硬件层面上的真正同时执行。 串行： 串行是指任务按照严格的顺序执行，一个任务执行完毕后下一个任务才能开始。 在单核系统中，如果没有并发机制的话，所有任务只能串行执行。 即使在多核系统中，若没有充分利用多核特性，也可能表现为串行执行。 操作系统中常见的锁类型 互斥锁（Mutexes） 最基本的同步原语之一，确保任何时候只有一个线程可以访问临界区。 当锁被占用时，请求锁的线程会被操作系统挂起（放入等待队列），直至锁释放后重新调度。 高开销主要在于上下文切换和线程调度。 自旋锁（Spin Locks） 同样保证互斥访问，但在尝试获取锁时，线程不放弃CPU，而是在原地循环等待（自旋）。 适用于锁保持时间极短且线程调度开销较大的环境，如低级别的内核代码。 若锁持有时间过长，自旋锁可能导致CPU使用率过高和不公平的调度。 读写锁（Read-Write Locks） 允许任意数量的读取者同时访问共享资源，但写入者会独占资源，阻止新的读取者和写入者。 在读多写少的情况下可以显著提高并发性能。 悲观锁与乐观锁 悲观锁：持保守态度，认为并发访问必然会导致冲突，所以在访问资源之前先获取锁。 乐观锁：相对乐观，认为冲突很少发生，一般不显式加锁，在更新数据时检测是否有冲突发生，如有则重试或回滚，常通过原子操作如CAS来实现。 信号量（Semaphores） 信号量不仅限于二元状态，可以是一个整数值，表示可供使用的资源数量。 当请求资源的线程发现信号量值小于请求值时，同样会被阻塞。 用于控制对有限资源的并发访问，如数据库连接池或文件句柄等。 条件变量（Condition Variables） 结合互斥锁使用，条件变量提供了一种基于条件的同步机制。 线程可以在条件不满足时释放锁并进入等待状态，当条件满足时被其他线程唤醒。 Java中常见的锁类型 操作系统中的五种IO模型 阻塞 I/O(Blocking I/O, BIO) 非阻塞 I/O(Non-blocking I/O, NIO) I/O 多路复用(I/O Multiplexing) 信号驱动 I/O(Signal-driven I/O) 异步 I/O(Asynchronous I/O, AIO) Java中的三种IO模型 阻塞 I/O(Blocking I/O, BIO) 非阻塞 I/O(Non-blocking I/O, NIO) 异步 I/O(Asynchronous I/O, AIO) Previous 面试题 Next 组成原理 "},"1CompositionPrinciple/组成原理.html":{"url":"1CompositionPrinciple/组成原理.html","title":"组成原理","keywords":"","body":"组成原理 Previous 阅读指南 Next 操作系统 "},"2OperatingSystem/操作系统.html":{"url":"2OperatingSystem/操作系统.html","title":"操作系统","keywords":"","body":"操作系统 Previous 组成原理 Next 网络 "},"3Network/网络.html":{"url":"3Network/网络.html","title":"网络","keywords":"","body":"网络 Previous 操作系统 Next 数据结构 "},"4DataStructure/数据结构.html":{"url":"4DataStructure/数据结构.html","title":"数据结构","keywords":"","body":"数据结构 Previous 网络 Next 算法 "},"5Algorithm/算法.html":{"url":"5Algorithm/算法.html","title":"算法","keywords":"","body":"算法 Previous 数据结构 "},"6Java/Java/Java基础.html":{"url":"6Java/Java/Java基础.html","title":"Java 基础","keywords":"","body":"Java基础 Next Java 集合 "},"6Java/Java/Java集合.html":{"url":"6Java/Java/Java集合.html","title":"Java 集合","keywords":"","body":"Java集合 Previous Java 基础 Next Java 并发 "},"6Java/Java/Java并发.html":{"url":"6Java/Java/Java并发.html","title":"Java 并发","keywords":"","body":"什么是JUC 指的是java.util下的三个并发编程工具包。 java.util.concurrent java.util.concurrent.atomic java.util.concurrent.locks 线程的相关概念 进程： 进程是操作系统中资源分配和调度的基本单位，代表着系统中运行的一个程序实例。 每个进程都有独立的内存空间和其他系统资源。 不同的进程之间相互隔离，通过进程间通信（IPC）机制进行信息交互。 线程： 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程内部的一个独立执行流。 一个进程中可以包含多个线程。这些线程共享进程的内存空间和其他资源，因此创建和切换线程的开销小于进程。 多线程可以实现进程内部的并发执行，提高CPU利用率。 协程： 协程是一种用户态的轻量级线程实现，也称作协作式多任务。 它不同于操作系统调度的线程，协程的调度完全由用户程序控制。 协程可以在函数调用时保存上下文并在适当时候恢复执行，允许在单个线程中模拟出多任务效果，且没有线程切换的开销。 同步： 同步指的是一个操作完成后才会执行下一个操作。 比如在编程中调用一个函数，直到该函数返回结果后，后续代码才会继续执行。 同步执行不会立即返回控制权，而是等待任务完成。 异步： 异步则是指发起一个操作后，无需等待该操作完成即可继续执行后续代码。 操作结果通过回调，或者通过事件等机制通知调用者。 这种模式下，程序不会阻塞等待某个操作结束，即调用发出后不必等待响应就可以去做别的事情。 阻塞： 阻塞是指在执行某个操作（如I/O请求）时，调用线程或进程会暂停执行，直到该操作完成。 在此期间，操作系统可能将CPU时间片分配给其他可执行的线程或进程。 非阻塞： 非阻塞操作则是指调用发出后，调用者不会被挂起，而是立即返回一个状态（如“未准备好”）。 然后调用者可以选择轮询检查操作是否完成，或者通过事件通知机制得知操作完成。 并发： 并发是指在一段时间内多个任务交替执行，从宏观上看似乎同时发生，但实际上由于CPU时间片轮转，微观上并非真正的同时执行。 并发强调的是多个任务在执行时间上的重叠。 并行： 并行指两个或多个任务在同一时刻真正地同时执行，尤其在多核或多处理器环境中，每个核心可以独立执行任务，实现物理上的同时处理。 并行强调的是在硬件层面上的真正同时执行。 串行： 串行是指任务按照严格的顺序执行，一个任务执行完毕后下一个任务才能开始。 在单核系统中，如果没有并发机制的话，所有任务只能串行执行。 即使在多核系统中，若没有充分利用多核特性，也可能表现为串行执行。 线程的创建方式 Java实现多线程的方式主要有以下4种： 继承Thread类 实现Runnable接口 实现Callable接口 开启线程池 继承Thread类 public class MyThread extends Thread { @Override public void run() { // 任务代码 System.out.println(\"线程 \" + Thread.currentThread().getName() + \" 正在运行...\"); } public static void main(String[] args) { MyThread thread = new MyThread(); thread.start(); // 启动线程 } } start()方法源码 注意：Java语言本身是不能直接开启线程的，通过查看start()方法的源代码，可以看到Java是通过调用一个叫start0()的native方法来实现开启线程的操作的。 /** * Thread.java源码中start()方法。 */ public synchronized void start() { if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try { // 调用start0()方法 start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } } // 由操作系统本地方法创建 private native void start0(); Java中的线程 Java默认有两个线程：main 和 GC main是用户线程 GC是守护线程 用户线程和守护线程： 用户线程：自定义线程（比如new Thread()） 守护线程：后台中一种特殊的线程，比如垃圾回收 当JVM中所有的用户线程都结束后，JVM会自动关闭，即使此时还有守护线程在运行。 实现Runnable接口 public class RunnableExample implements Runnable { @Override public void run() { // 任务代码 System.out.println(\"线程 \" + Thread.currentThread().getName() + \" 正在运行...\"); } public static void main(String[] args) { Runnable task = new RunnableExample(); Thread thread = new Thread(task); thread.start(); } } 实现Callable接口 public class CallableExample implements Callable { @Override public String call() throws Exception { // 任务代码，可以有返回值 System.out.println(\"线程 \" + Thread.currentThread().getName() + \" 正在运行...\"); return \"Callable任务已完成\"; } public static void main(String[] args) throws InterruptedException, ExecutionException { Callable callable = new CallableExample(); FutureTask futureTask = new FutureTask<>(callable); Thread thread = new Thread(futureTask); thread.start(); // 获取Callable任务的结果 String result = futureTask.get(); System.out.println(\"任务结果：\" + result); } } Runnable接口和Callable接口区别 是否有返回值：Runnable无返回值，Callable有返回值 是否抛出异常：call方法计算一个结果，如果不能这样做，就会抛出异常 实现方法名称不同，Runnable接口是run方法，Callable接口是call方法 开启线程池 public class ThreadPoolExample implements Runnable { @Override public void run() { // 任务代码 System.out.println(\"线程 \" + Thread.currentThread().getName() + \" 正在运行...\"); } public static void main(String[] args) { // 创建固定大小的线程池 ExecutorService executorService = Executors.newFixedThreadPool(5); // 提交任务 for (int i = 0; i 多线程的编程步骤 编程步骤 第一步：创建资源类，定义属性和操作方法 第二步：创建多线程去调用资源类的方法 卖票例子 public class SaleTicket { public static void main(String[] args) { Ticket ticket = new Ticket(); // 第二步：创建多线程调用资源类的方法，这里开启三个线程A,B,C卖票 new Thread(new Runnable() { @Override public void run() { for (int i = 0; i 0) { num--; System.out.println(Thread.currentThread().getName() + \"卖出一张票:\" + \"余票\" + num); } } } 线程的生命周期 线程从开启到执行完成，会经历一些状态，这些状态一起组成了线程的生命周期。 线程的状态 /** * Thread.java源码中State枚举定义了线程可能处于的不同状态。 */ public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED; } 线程的生命周期 新建状态（NEW） 当一个 Thread 对象被创建但尚未调用其 start() 方法时，线程处于新建状态。 此时线程对象已存在，但并没有分配到任何操作系统资源，也没有开始执行。 可运行状态（RUNNABLE） 包括了两个子状态： 从Java的角度看，RUNNABLE状态包括了READY和RUNNING两种实际的操作系统状态。 i. 就绪状态（READY）: 线程已经调用了 start() 方法，且线程调度器随时可以将其分配给CPU进行执行。 线程在就绪队列中等待，一旦得到CPU时间片，它就转为运行状态。 ii. 运行状态（RUNNING）: 线程正在执行其 run() 方法。 阻塞状态（BLOCKED） 线程试图获取一个监视器锁（synchronized块或方法），但锁被其他线程持有，因此该线程会暂时停止执行并进入阻塞状态，直到获得锁。 等待状态（WAITING） 线程调用了 Object.wait() 、 Thread.join() 或者 LockSupport.park() 方法，进入了无限期等待状态。 线程不会继续执行，除非其他线程对此线程发出 notify() 或者 notifyAll() 信号。 定时等待状态（TIMED_WAITING） 线程调用了带有超时参数的方法如 Thread.sleep(long millis) 、 Object.wait(long timeout) 、 Thread.join(long millis) 、 LockSupport.parkNanos() 或 LockSupport.parkUntil() 后进入此状态。 在这个状态下，线程将在指定的时间过后自动返回，不再需要其他线程的显式唤醒。 终止状态（TERMINATED） 线程完成了它的任务或者因为异常退出了 run() 方法，线程已经结束执行。 一旦线程达到终止状态，就不能再次变为其他状态。 wait()和sleep()的区别 来自不同的类 wait => Object，任何对象实例都能调用 sleep => Thread，Thread的静态方法 关于锁的释放 wait会释放锁；sleep不会释放锁，它也不需要占用锁 使用范围、捕获异常不同 wait：必须在同步代码块中使用，不需要捕获异常 sleep：可以在任何地方使用，必须要捕获异常 Synchronized与Lock锁 synchronized实现卖票例子 public class SaleTicket { public static void main(String[] args) { Ticket ticket = new Ticket(); // 创建多线程调用资源类的方法:这里开启三个线程A,B,C卖票 new Thread(new Runnable() { @Override public void run() { for (int i = 0; i 0) { num--; System.out.println(Thread.currentThread().getName() + \"卖出一张票:\" + \"余票\" + num); } } } lock锁实现卖票例子 import java.util.concurrent.locks.ReentrantLock; public class LSaleTicket { public static void main(String[] args) { LTicket lTicket = new LTicket(); new Thread(() -> { for (int i = 0; i { for (int i = 0; i { for (int i = 0; i 0) { num--; System.out.println(Thread.currentThread().getName() + \"卖出一张票，余票\" + num); } // 必须放在finally块中解锁，防止死锁 } finally { lock.unlock(); } } } 两者对比 特性 Synchronized Lock接口（如ReentrantLock） 语法级别 关键字（JVM内置） 类/接口（API级别） 使用方式 修饰方法或代码块 显示调用lock/unlock方法 自动释放锁 发生异常时会自动释放 必须手动unlock 异常安全性 内置异常安全 需要在finally块中unlock确保释放 可中断性 不支持中断 支持中断（tryLockInterruptibly） 超时等待 不支持 支持超时等待（tryLock(long timeout, TimeUnit unit)） 非阻塞尝试获取 不支持 支持非阻塞尝试（tryLock()） 锁定粒度 对象级别的锁 支持更细粒度的锁控制 公平性 非公平锁（默认） 可选公平锁或非公平锁 锁绑定条件 不直接支持 提供 Condition 接口，可精确唤醒线程 性能优化 JVM 1.6及以后有多种优化策略 用户可以根据场景选择合适的锁实现 注：synchronized 在 Java 1.6 及更高版本进行了大量性能优化，例如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等机制，使其在许多常见场景下的性能并不一定逊色于 Lock。然而，在高度竞争和需要更多高级特性的场合，Lock 接口及其实现提供了更大的灵活性和控制力。 八锁现象 简介 “8锁现象”（Eight Lock Phenomena）是在Java并发编程中讨论同步机制时提到的一个概念，它并不是指代具体的8种锁类型，而是用来形象化表示在使用synchronized关键字时可能出现的几种典型的同步状况或问题。 这些状况揭示了如何正确理解和运用synchronized关键字，以及在不同的上下文中锁住的对象和锁的粒度。 总结 普通同步方法：锁住的是调用方法的对象实例，谁先拿到锁谁先执行，同一个对象拿到的是同一把锁。 静态同步方法：锁住的是类的Class对象（ClassName.Class），由于类只加载一 次，因此同一类的所有实例共享同一把锁。 同步代码块：锁住的是Synchonized 括号里配置的对象，可以指定任意对象作为锁，与普通同步方法的区别在于锁对象的灵活性。 非静态非同步方法：由于不受锁控制，因此不受锁的影响。 代码举例 两个同步方法，同一个对象演示 public class Lock_8 { public static void main(String[] args) throws InterruptedException { Phone phone = new Phone(); new Thread(() -> { try { phone.sendEmail(); } catch (Exception e) { e.printStackTrace(); } }, \"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(() -> { try { phone.sendSMS(); } catch (Exception e) { e.printStackTrace(); } }, \"B\").start(); } } class Phone { public synchronized void sendEmail() throws Exception { System.out.println(\"---sendEmail---\"); } public synchronized void sendSMS() throws Exception { System.out.println(\"---sendSMS---\"); } } 结果：同一把锁，所以先sendEmail ---sendEmail--- ---sendSMS--- 两个同步方法，同一个对象，停 4 秒在短信方法内 class Phone { public synchronized void sendEmail() throws Exception { TimeUnit.SECONDS.sleep(3); System.out.println(\"---sendEmail---\"); } public synchronized void sendSMS() throws Exception { System.out.println(\"---sendSMS---\"); } } 同一把锁，依然是先sendEmail ---sendEmail--- ---sendSMS--- 两个对象，两个同步方法（注意睡眠时间） public class Lock_8 { public static void main(String[] args) throws InterruptedException { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -> { try { phone1.sendEmail(); } catch (Exception e) { e.printStackTrace(); } }, \"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(() -> { try { phone2.sendSMS(); } catch (Exception e) { e.printStackTrace(); } }, \"B\").start(); } } class Phone { public synchronized void sendEmail() throws Exception { TimeUnit.SECONDS.sleep(2); System.out.println(\"---sendEmail---\"); } public synchronized void sendSMS() throws Exception { System.out.println(\"---sendSMS---\"); } } 结果：不同锁，先sendSMS，不同对象在普通同步方法分配的是不同的锁 ---sendSMS--- ---sendEmail--- 一个对象，新增普通的 hello 方法 public class Lock_8 { public static void main(String[] args) throws InterruptedException { Phone phone = new Phone(); new Thread(() -> { try { phone.sendEmail(); } catch (Exception e) { e.printStackTrace(); } }, \"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(() -> { try { phone.sendSMS(); } catch (Exception e) { e.printStackTrace(); } }, \"B\").start(); new Thread(() -> { try { phone.hello(); } catch (Exception e) { e.printStackTrace(); } }, \"C\").start(); } } class Phone { public synchronized void sendEmail() throws Exception { TimeUnit.SECONDS.sleep(4); System.out.println(\"---sendEmail---\"); } public synchronized void sendSMS() throws Exception { System.out.println(\"---sendSMS---\"); } public void hello() { System.out.println(\"---hello---\"); } } 结果：先hello，不受锁的影响 ---hello--- ---sendEmail--- ---sendSMS--- 两个静态的同步方法，一个对象 public class Lock_8 { public static void main(String[] args) throws InterruptedException { Phone phone = new Phone(); new Thread(() -> { try { phone.sendEmail(); } catch (Exception e) { e.printStackTrace(); } }, \"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(() -> { try { phone.sendSMS(); } catch (Exception e) { e.printStackTrace(); } }, \"B\").start(); } } class Phone { public static synchronized void sendEmail() throws Exception { TimeUnit.SECONDS.sleep(2); System.out.println(\"---sendEmail---\"); } public static synchronized void sendSMS() throws Exception { System.out.println(\"---sendSMS---\"); } } 结果：同一把锁，先sendEmail ---sendEmail--- ---sendSMS--- 两个对象！增加两个静态的同步方法 public class Lock_8 { public static void main(String[] args) throws InterruptedException { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -> { try { phone1.sendEmail(); } catch (Exception e) { e.printStackTrace(); } }, \"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(() -> { try { phone2.sendSMS(); } catch (Exception e) { e.printStackTrace(); } }, \"B\").start(); } } class Phone { public static synchronized void sendEmail() throws Exception { TimeUnit.SECONDS.sleep(2); System.out.println(\"---sendEmail---\"); } public static synchronized void sendSMS() throws Exception { System.out.println(\"---sendSMS---\"); } } 结果：同一把锁，锁的是类，依然是先sendEmail ---sendEmail--- ---sendSMS--- 1个静态的同步方法，1个普通的同步方法 ，一个对象（注意睡眠时间） public class Lock_8 { public static void main(String[] args) throws InterruptedException { Phone phone = new Phone(); new Thread(() -> { try { phone.sendEmail(); } catch (Exception e) { e.printStackTrace(); } }, \"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(() -> { try { phone.sendSMS(); } catch (Exception e) { e.printStackTrace(); } }, \"B\").start(); } } class Phone { public synchronized void sendEmail() throws Exception { TimeUnit.SECONDS.sleep(4); System.out.println(\"---sendEmail---\"); } public static synchronized void sendSMS() throws Exception { System.out.println(\"---sendSMS---\"); } } 结果：不同锁，先sendSMS ---sendSMS--- ---sendEmail--- 1个静态的同步方法，1个普通的同步方法 ，两个对象（注意睡眠时间） public class Lock_8 { public static void main(String[] args) throws InterruptedException { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -> { try { phone1.sendEmail(); } catch (Exception e) { e.printStackTrace(); } }, \"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(() -> { try { phone2.sendSMS(); } catch (Exception e) { e.printStackTrace(); } }, \"B\").start(); } } class Phone { public synchronized void sendEmail() throws Exception { TimeUnit.SECONDS.sleep(4); System.out.println(\"---sendEmail---\"); } public static synchronized void sendSMS() throws Exception { System.out.println(\"---sendSMS---\"); } } 结果：不同锁，先sendSMS ---sendSMS--- ---sendEmail--- 线程间通信 概念 在多线程模式下进行工作，除了要考虑各个线程之间是否同步、如何竞争锁等问题，还要考虑这样一个问题：线程之间有的时候需要相互配合来共同完成一件事情。 把一个大的任务拆分成多个不同的任务线，每个任务线中都有更小的执行步骤。各个线程之间需要彼此配合：A 线程执行一步唤醒 B 线程，自己等待；B 线程执行一步，唤醒 A 线程，自己等待…… 核心语法 Object 类的 wait() 方法 wait() 方法会导致当前线程进入等待状态 必须是另外一个线程调用 notify() 或 notifyAll() 方法来唤醒 “for this object” 表示还是要使用同一个对象分别调用 wait()、notify()、notifyAll() 这些方法 Object 类的 notify() 方法 notify() 方法只唤醒一个线程 处于等待状态的线程会被存放在对象监视器中的一个数组中 如果在这个对象的监视器中维护的处于等待状态的线程是多个，那么 notify() 方法会随机唤醒一个 notfiy() 方法无法精确唤醒一个指定的线程，这个需求可以通过 Lock + Condition 方式实现（定制化通信） Object 类的 notifyAll() 方法 唤醒当前对象监视器上等待的所有线程。 代码演示 模拟生产者消费者模型 设定一个成员变量，作为两个线程都要操作的共享数据，设置初始化值为 0 A 线程执行 +1 操作 B 线程执行 -1 操作 A、B 两个线程交替执行 synchronized代码实现 public class STest { public static void main(String[] args) { Share share = new Share(); new Thread(() -> { for (int i = 0; i { for (int i = 0; i 0) { this.wait(); } num++; System.out.println(Thread.currentThread().getName() + \"::\" + num); this.notifyAll(); } public synchronized void decr() throws InterruptedException { if (num Lock代码实现 /** * 与上面案例使用的方法不同 * Condition.await()--->Object.wait() * Condition.signal()--->Object.notify() * Condition.signalAll()--->Object.notifyAll() */ public class Demo02 { public static void main(String[] args) { Share share = new Share(); new Thread(() -> { for (int i = 0; i { for (int i = 0; i { for (int i = 0; i 0) { // 等待 condition.await(); } num++; System.out.println(Thread.currentThread().getName() + \"::\" + num); // 通知 condition.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public void decr() throws InterruptedException { lock.lock(); try { while (num 虚假唤醒（使用 while 解决） 当上面的例子中，线程数量从两个增加到四个，计算结果就会出错： thread-a 线程：1 thread-c 线程：2 thread-a 线程：3 thread-b 线程：2 thread-d 线程：1 原因：使用 if 的情况（仅判断一次） 假设C线程判断num后，进行等待（在哪里等就在哪里醒），被别的线程唤醒后不会再进行num判断，会导致数值不符合预期。 解决：使用 while 解决问题 要解决虚假唤醒问题，就需要对线程间通信时的判断条件使用 while 循环结构来执行，而不是 if 分支判断。 定制化通信 可以通过可重入锁的多种情况来达成，每把钥匙都对应同一把重入锁 private Lock lock = new ReentrantLock(); //声明钥匙 A private Condition conditionA = lock.newCondition(); //声明钥匙 B private Condition conditionB = lock.newCondition(); //声明钥匙 C private Condition conditionC = lock.newCondition(); conditionA.await(); //A等待 conditionA.signal(); //唤醒A 代码演示 A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C 按照此顺序循环 10 轮 public class Laptoy { public static void main(String[] args) { Test test = new Test(); new Thread(() -> { for (int i = 0; i { for (int i = 0; i { for (int i = 0; i 集合的线程安全问题 解决ArrayList线程不安全 Vector List list = new Vector<>(); Collections.synchronizedList List list = Collections.synchronizedList(new ArrayList<>()); CopyOnWriteArrayList List list = new CopyOnWriteArrayList<>(); 解决HashSet线程不安全 Collections.synchronizedSet Set set = Collections.synchronizedSet(new HashSet<>()); CopyOnWriteArraySet Set set = new CopyOnWriteArraySet<>(); 解决HashMap线程不安全 Hashtable Map map = new Hashtable<>(); Collections.synchronizedMap Map map = Collections.synchronizedMap(new HashMap<>()); ConcurrentHashMap Map map = new ConcurrentHashMap<>(); 辅助类 JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作带来的开销。 CountDownLatch: 减少计数 CyclicBarrier: 循环栅栏 Semaphore: 信号灯 CountDownLatch: 减少计数 场景举例：50 个同学离开教室再锁门 import java.util.concurrent.CountDownLatch; public class ClassroomLockExample { private static final int TOTAL_STUDENTS = 50; private static CountDownLatch latch = new CountDownLatch(TOTAL_STUDENTS); public static void main(String[] args) { // 假设这是教室监控系统 Thread monitorThread = new Thread(() -> { try { latch.await(); // 监控系统等待所有学生离开 System.out.println(\"All students have left the classroom. Locking the door.\"); } catch (InterruptedException e) { System.err.println(\"Monitor was interrupted while waiting for students to leave.\"); } }, \"Classroom Monitor\"); monitorThread.start(); // 启动50个学生线程代表每个学生离开教室的动作 for (int i = 1; i { System.out.println(\"Student \" + i + \" is leaving the classroom.\"); // 模拟学生离开教室的行为 // ... // 离开教室后，计数器减一 latch.countDown(); }, \"Student \" + i); studentThread.start(); } } } /*在这个例子中，CountDownLatch初始化为50，表示有50个同学。每当一个同学完成离开教室的动作，就调用一次countDown()方法减少计数器。当计数器减到0时，意味着所有同学都已经离开了教室，此时主线程（在这里表现为“监控系统”线程）的latch.await()会解除阻塞，然后可以执行锁门的操作。这样就能确保所有同学离开后再锁门。*/ CyclicBarrier: 循环栅栏 场景举例：集齐 7 颗龙珠就可以召唤神龙 import java.util.concurrent.BrokenBarrierException; import java.util.concurrent.CyclicBarrier; public class DragonBallCyclicBarrierExample { private static final int BALL_FINDER_COUNT = 7; private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(BALL_FINDER_COUNT, () -> { System.out.println(\"All 7 Dragon Balls have been gathered by all finders! Summoning Shenron!\"); // ... 召唤神龙的逻辑 }); public static void main(String[] args) { // 创建七个寻找者线程 for (int i = 1; i { System.out.println(\"Finder \" + i + \" started searching for a Dragon Ball.\"); // 模拟寻找龙珠的行为 // ... System.out.println(\"Finder \" + i + \" found a Dragon Ball and is now heading to the meeting point.\"); try { // 找到龙珠后，到达集合点 cyclicBarrier.await(); } catch (InterruptedException | BrokenBarrierException e) { System.err.println(\"Finder \" + i + \" encountered an error while waiting at the meeting point.\"); e.printStackTrace(); } }, \"Finder \" + i); finderThread.start(); } } } /*在这个例子中，当七个寻找者线程全部调用cyclicBarrier.await()方法时，它们都会被阻塞，直到最后一个寻找者调用此方法。此时，CyclicBarrier的回调函数会被触发，表示所有寻找者已经成功汇集，然后一起召唤神龙。CyclicBarrier可以重复使用，也就是说在此次召唤神龙之后，还可以用于下一轮的龙珠收集和召唤。*/ Semaphore: 信号灯 场景举例：10 辆车 3 个车位 import java.util.concurrent.Semaphore; public class ParkingLotExample { private static final int MAX_PARKING_SPOTS = 3; private static Semaphore parkingSpots = new Semaphore(MAX_PARKING_SPOTS); public static void main(String[] args) { // 假设有10辆车需要停车 for (int i = 0; i { try { // 请求一个停车位 parkingSpots.acquire(); System.out.println(\"Vehicle \" + (i + 1) + \" parked in the spot.\"); // 模拟车辆停车的时间 Thread.sleep(1000); System.out.println(\"Vehicle \" + (i + 1) + \" leaving the spot.\"); } catch (InterruptedException e) { System.err.println(\"Vehicle interrupted while trying to park.\"); } finally { // 无论是否发生异常，车辆离开后都要释放车位 parkingSpots.release(); } }).start(); } } } /*在这个例子中，Semaphore初始化为3，代表有3个车位。每辆车作为一个线程运行，当尝试获取一个车位（调用parkingSpots.acquire()）时，如果车位已满（即信号量的许可证为0），那么该线程将被阻塞直至有车离开并释放车位。当车辆离开时，会调用parkingSpots.release()释放车位，允许下一辆车停入。这样就能保证任何时候最多只有3辆车在车位上停放。*/ 读写锁 概念 一个资源可以被多个读线程访问，也可以被一个写线程访问。但不能同时存在读写线程，读写互斥，读读共享。 读写锁：ReentrantReadWriteLock 1、 读锁为ReentrantReadWriteLock.ReadLock，readLock()方法 2、 写锁为ReentrantReadWriteLock.WriteLock，writeLock()方法 创建读写锁对象：private ReadWriteLock rwLock = new ReentrantReadWriteLock(); 1、写锁 加锁rwLock.writeLock().lock(); 2、写锁 解锁rwLock.writeLock().unlock(); 3、读锁 加锁rwLock.readLock().lock(); 4、读锁 解锁rwLock.readLock().unlock(); 代码演示： import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLockDemo { public static void main(String[] args) { MyCache myCache = new MyCache(); // 写锁线程 for (int i = 1; i { myCache.put(num + \"\", num + \"\"); }, String.valueOf(i)).start(); } // 读锁线程 for (int i = 1; i { myCache.get(num + \"\"); }, String.valueOf(i)).start(); } } } class MyCache { ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private volatile Map map = new HashMap<>(); // 写数据 public void put(String key, Object value) { // 写锁 加锁 readWriteLock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() + \" 正在写操作\" + key); // 模拟写操作花时 TimeUnit.MICROSECONDS.sleep(300); map.put(key, value); System.out.println(Thread.currentThread().getName() + \" 写完了\" + key); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 写锁 解锁 readWriteLock.writeLock().unlock(); } } // 读数据 public Object get(String key) { Object result = null; // 读锁 加锁 readWriteLock.readLock().lock(); try { System.out.println(Thread.currentThread().getName() + \" 正在读操作\" + key); TimeUnit.MICROSECONDS.sleep(300); result = map.get(key); System.out.println(Thread.currentThread().getName() + \" 读完了\" + key); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 读锁 解锁 readWriteLock.readLock().unlock(); } return result; } } 锁的局限性 无锁：多线程抢夺资源 synchronized和ReentrantLock：都是独占，每次只可以一个操作，不能共享 ReentrantReadWriteLock：读读可以共享，提升性能，但是不能多人写 缺点：造成死锁（一直读，不能写），读进程不能写，写进程可以读。 通过（写锁释放前可以读这一特性）进行锁降级，可以提高效率 写锁的锁降级 目的： 写锁降级为读锁（一般等级写锁高于读锁）（利用写锁时可以读这一特性） 正常情况是获取写锁，释放写锁，获取读锁，释放读锁 降级流程：获取写锁->获取读锁->释放写锁->释放读锁--->其实就是在写锁释放前进行获取读锁，可以提高线程效率 代码演示： public class Demo1 { public static void main(String[] args) { //可重入读写锁对象 ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(); ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();//读锁 ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();//写锁 //锁降级 //1 获取写锁 writeLock.lock(); System.out.println(\"laptoy\"); //2 获取读锁 readLock.lock(); System.out.println(\"---read---\"); //3 释放写锁 writeLock.unlock(); //4 释放读锁 readLock.unlock(); } } Java中各种锁的理解 公平锁与非公平锁 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必唤醒所有线程，会减少唤起线程的数量。 缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 创建可重入锁的时候可以设置公平或非公平锁（默认是非公平锁 ） 可重入锁 synchronized：隐式，自动获取释放锁 Lock：显式，手动获取释放锁 synchronized演示可重入锁 1、拿到外层的锁就可以拿到内层的锁 public class SyncLock { public static void main(String[] args) { Object o = new Object(); new Thread(() -> { synchronized (o) { System.out.println(Thread.currentThread().getName() + \"外层锁\"); synchronized (o) { System.out.println(Thread.currentThread().getName() + \"中层锁\"); synchronized (o) { System.out.println(Thread.currentThread().getName() + \"内层锁\"); } } } }, \"laptoy-t\").start(); } } // laptoy-t外层锁 // laptoy-t中层锁 // laptoy-t内层锁 2、递归锁 public class SyncLock { public static void main(String[] args) { new SyncLock().add(); } synchronized void add() { add(); } } // 栈溢出异常，证明可重入锁可以递归调用 Lock演示可重入锁 public class SyncLock { public static void main(String[] args) { Lock lock = new ReentrantLock(); new Thread(() -> { try { lock.lock(); System.out.println(Thread.currentThread().getName() + \"外层锁\"); try { lock.lock(); System.out.println(Thread.currentThread().getName() + \"内层锁\"); } finally { lock.unlock(); } } finally { lock.unlock(); } }, \"laptoy-t\").start(); } } // laptoy-t外层锁 // laptoy-t内层锁 死锁 两个或两个以上进程执行过程中，因为争夺资源而造成的一种互相等待的现象，如果没有外力干涉，他们无法再执行下去。 快速演示死锁代码 package com.walle.javaConcurrent.deadLock; public class DeadLock { static Object a = new Object(); static Object b = new Object(); public static void main(String[] args) { new Thread(() -> { synchronized (a) { System.out.println(Thread.currentThread().getName() + \"线程 持有锁a，试图获取锁b\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (b) { System.out.println(Thread.currentThread().getName() + \"线程 获取锁b\"); } } }, \"A\").start(); new Thread(() -> { synchronized (b) { System.out.println(Thread.currentThread().getName() + \"线程 持有锁b，试图获取锁b\"); synchronized (a) { System.out.println(Thread.currentThread().getName() + \"线程 获取锁a\"); } } }, \"B\").start(); } } // A线程 持有锁a，试图获取锁b // B线程 持有锁b，试图获取锁b 验证死锁 执行jps查询正在执行的进程 执行jstack 8832追踪堆栈 排查死锁（工作中） 日志信息90% 堆栈信息10% 阻塞队列 概念 阻塞队列是共享队列（多线程操作），一端输入，一端输 所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起 执行流程 当队列是空的，从队列中获取元素的操作将会被阻塞 当队列是满的，从队列中添加元素的操作将会被阻塞 试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素 试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增 举个例子 通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然 当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列 当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒 种类 常用的阻塞队列： ArrayBlockingQueue（数组有界阻塞队列） 生产者和消费者共用同一个锁，无法并行 LinkedBlockingQueue（链表有界阻塞队列），默认值为integer.MAX_VALUE 生产者和消费者采用了独立的锁，可以并行 SynchronousQueue 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。 方法 方法类型 抛出异常 特殊值 阻塞 超时 插入元素 add(e) offer(e) put(e) offer(e,time,unit) 移除元素 remove() poll() take() poll(time,unit) 获取首部元素 element() peek() 不可用 不可用 抛出异常 当队列满再add()会抛出IllegalStateException：Queue full 当队列空再remove()会抛NoSuchElementException 特殊值 插入成功true，失败false 移除成功返回出队列的元素，失败返回null 阻塞 队列满继续put会阻塞直到put成功或响应中断退出 队列空继续take会阻塞直到take成功 超时退出 阻塞队列满时，队列阻塞生产者一定时间，超时后生产者线程退出 代码演示 抛出异常演示 public class BlockingQueueDemo { public static void main(String[] args) { ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3); System.out.println(blockingQueue.add(\"a\")); // true System.out.println(blockingQueue.add(\"b\")); // true System.out.println(blockingQueue.add(\"c\")); // true //System.out.println(blockingQueue.add(\"d\")); // 抛异常 System.out.println(blockingQueue.element());// a，检查出即将出队列的元素 System.out.println(blockingQueue.remove()); // a System.out.println(blockingQueue.remove()); // b System.out.println(blockingQueue.remove()); // c //System.out.println(blockingQueue.remove()); //抛异常 } } 特殊值演示 public class BlockingQueueDemo { public static void main(String[] args) { ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3); System.out.println(blockingQueue.offer(\"a\")); // true System.out.println(blockingQueue.offer(\"b\")); // true System.out.println(blockingQueue.offer(\"c\")); // true System.out.println(blockingQueue.offer(\"d\")); // false System.out.println(blockingQueue.peek()); // a，检查出即将出队列的元素 System.out.println(blockingQueue.poll()); // a System.out.println(blockingQueue.poll()); // b System.out.println(blockingQueue.poll()); // c System.out.println(blockingQueue.poll()); // null } } 阻塞演示 public class BlockingQueueDemo { public static void main(String[] args) throws InterruptedException { ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3); blockingQueue.put(\"a\"); blockingQueue.put(\"b\"); blockingQueue.put(\"c\"); // blockingQueue.put(\"d\"); //阻塞 System.out.println(blockingQueue.take()); // a System.out.println(blockingQueue.take()); // b System.out.println(blockingQueue.take()); // c // System.out.println(blockingQueue.take()); // 阻塞 } } 超时演示 public class BlockingQueueDemo { public static void main(String[] args) throws InterruptedException { ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3); System.out.println(blockingQueue.offer(\"a\", 3L, TimeUnit.SECONDS)); // true System.out.println(blockingQueue.offer(\"b\", 3L, TimeUnit.SECONDS)); // true System.out.println(blockingQueue.offer(\"c\", 3L, TimeUnit.SECONDS)); // true System.out.println(blockingQueue.offer(\"d\", 3L, TimeUnit.SECONDS)); // false，阻塞三秒后返回false System.out.println(blockingQueue.poll(3L, TimeUnit.SECONDS)); // a System.out.println(blockingQueue.poll(3L, TimeUnit.SECONDS)); // b System.out.println(blockingQueue.poll(3L, TimeUnit.SECONDS)); // c System.out.println(blockingQueue.poll(3L, TimeUnit.SECONDS)); // null，阻塞三秒后返回null } } 线程池 三大方式 七大参数 四种拒绝策略 概念 一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。 线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。 特点 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的销耗。 提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 继承图 Executors帮我们封装好的线程池，拿来即用 Executors.newFixedThreadPool(5)：一池5线程（定长线程池） Executors.newCachedThreadPool()：自动分配线程数量（可缓存线程池） Executors.newSingleThreadExecutor()： 一池一线程（单线程化线程池） public class Demo01 { public static void main(String[] args) { // 一池5线程 ExecutorService pool1 = Executors.newFixedThreadPool(5); // 自动分配多少线程 ExecutorService pool2 = Executors.newCachedThreadPool(); // 一池一线程 ExecutorService pool3 = Executors.newSingleThreadExecutor(); try { for (int i = 0; i { System.out.println(Thread.currentThread().getName() + \" 执行成功\"); }); } } catch (Exception e) { e.printStackTrace(); } finally { pool1.shutdown(); } } } // 以一池5线程演示结果 // pool-1-thread-2 执行成功 // pool-1-thread-4 执行成功 // pool-1-thread-1 执行成功 // pool-1-thread-3 执行成功 // pool-1-thread-1 执行成功 // pool-1-thread-4 执行成功 // pool-1-thread-2 执行成功 // pool-1-thread-5 执行成功 // pool-1-thread-4 执行成功 // pool-1-thread-1 执行成功 // pool-1-thread-3 执行成功 底层都是new ThreadPoolExecutor public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue()); } public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())); } ThreadPoolExecutor的七个参数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize 执行流程 建线程池时不会创建线程，执行run()才会进行execute()创建 假设最大线程数为5，核心线程为2，阻塞队列为3，现在进来9个线程 进来2个线程，调用线程池核心线程执行 （1 2） 继续来三个线程（超过核心线程数），这三个就进入阻塞队列 （3 4 5） 继续来三个线程（超过阻塞队列但未超过最大线程数），这三个线程会直接优先创建 （6 7 8） 继续来线程（超过最大线程数），会通过拒绝策略进行拒绝 （9 ...） 拒绝策略(handler) AbortPolicy(默认)：丢弃任务，并抛出拒绝执行 RejectedExecutionException CallerRunsPolicy：不会丢弃任务，也不会抛出异常，将任务返还给调用者执行 DiscardPolicy：直接丢弃 DiscardOldestPolicy：抛弃阻塞队列等待时间最久的任务，把当前任务加入队列中尝试再次提交当前任务 线程工厂 线程工厂指定创建线程的方式，需要实现 ThreadFactory 接口，并实现 newThread(Runnable r) 方法。该参数可以不用指定，Executors 框架已经为我们实现了一个默认的线程工厂： /** * The default thread factory. */ private static class DefaultThreadFactory implements ThreadFactory { private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() { SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; } public Thread newThread(Runnable r) { Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; } } 自定义线程池 不推荐直接使用功能线程池创建，而是通过ThreadPoolExecutor的方式传递参数创建 public class Demo01 { public static void main(String[] args) { ThreadPoolExecutor threadPool = new ThreadPoolExecutor( 2, 5, 2L, TimeUnit.SECONDS, new ArrayBlockingQueue<>(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); try { for (int i = 0; i { System.out.println(Thread.currentThread().getName() + \" 执行成功\"); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool.shutdown(); } } } Fork/Join 概念 在JDK1.7出现，Fork/Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork/Join 框架要完成两件事情： Fork：把一个复杂任务进行分拆，大事化小 Join：把分拆任务的结果进行合并 任务分割：首先 Fork/Join 框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割 执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。 API介绍 RecursiveTask 用于有返回结果的任务 我们使用 Fork Join 框架只需要继承 RecursiveTask，然后重写 compute() 方法即可。在 compute() 方法中需要包含： 任务拆分的逻辑 任务拆分的操作：调用 fork() 方法 已拆分任务的合并：调用 join() 方法 子任务结果的合并：将 join() 方法的返回值合并起来 ForkJoinTask RecursiveTask的父类 代码演示 1、需求 完成从 1~100 的累加 2、思路 通过任务拆分、合并的方式来实现。拆分的逻辑是： 将大范围数值累加拆分为小范围数值累加。 在 1~10 区间范围内执行计算。 public class Demo01 { public static void main(String[] args) throws ExecutionException, InterruptedException { // 1、创建 Fork Join 任务池 ForkJoinPool pool = new ForkJoinPool(); // 2、创建任务对象 MyTask myTask = new MyTask(1, 100); // 3、将任务对象提交到任务池 ForkJoinTask forkJoinTask = pool.submit(myTask); // 4、获取任务执行结果 int finalResult = forkJoinTask.get(); System.out.println(\"finalResult = \" + finalResult); // 5、关闭池 pool.shutdown(); } } class MyTask extends RecursiveTask { // 区间开始位置 private final int begin; // 区间结束位置 private final int end; // 区间调整值：要通过拆分任务将区间调整到 10 以内 public static final int ADJUST_VALUE = 10; // 保存当前任务的结果 private int result = 0; // 声明构造器，设定当前任务的开始和结束位置 public MyTask(int begin, int end) { this.begin = begin; this.end = end; } @Override protected Integer compute() { // 1、判断当前区间是否是原子任务中可以执行计算的范围 if (end - begin 异步回调 CompletableFutur 简介 CompletableFuture 就是 Callable + FutureTask 组合的『超级强化版』 FutureTask 的核心接口 Futrue 通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个 Futrue 对象。在 Future 里面有 isDone() 方法来判断任务是否处理结束，还有 get() 方法可以一直阻塞直到任务结束然后获取结果。但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成。 Future 的主要缺点如下： 不支持手动完成 我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直等待它执行完成 不支持进一步的非阻塞调用 通过Future的get方法会一直阻塞到任务完成，但是想在获取任务之后执行额外的任务，因为Future不支持回调函数，所以无法实现这个功能 不支持链式调用 对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成一个链式的 pipeline 调用，这在Future 中是没法实现的。 不支持多个 Future 合并 比如我们有 10 个 Future 并行执行，我们想在所有的Future运行完毕之后，执行某些函数，是没法通过 Future 实现的。 不支持异常处理 Future 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题是不好定位的。 用法 1、执行无返回值任务 public class Demo01 { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture voidCompletableFuture = CompletableFuture.runAsync(() -> { System.out.println(Thread.currentThread().getName() + \"completableFuture1\"); }); voidCompletableFuture.get(); } } 2、执行有返回值任务 public class Demo01 { public static void main(String[] args) { CompletableFuture completableFuture = CompletableFuture.supplyAsync(() -> { System.out.println(Thread.currentThread().getName() + \"completableFuture2\"); int i = 1 / 0; return 1024; }); completableFuture.whenComplete((t, u) -> { System.out.println(\"t:\" + t); System.out.println(\"u:\" + u); }); } } stream流式计算 四大函数式接口 Java内置四大核心函数式接口 函数式接口 参数类型 返回类型 接口方法 Consumer 消费型接口 T void 对类型为T的对象应用操作，包含方法：void accept(T t) Supplier 供给型接口 无 T 返回类型为T的对象，包含方法：T get(); Function 函数型接口 T R 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t); Predicate 断定型接口 T boolean 确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：boolean test(T t); 代码举例 我们以一个简单的数组求和作为例子 三六九等：三（普通方法） 六（ForkJoin） 九（Stream并行流） 普通方法（顺序执行）： public class SumArrayExample { public static void main(String[] args) { SumArray sumArray = new SumArray(); int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9}; long startTime = System.nanoTime(); int sum = sumArray.sumSequentially(numbers); long endTime = System.nanoTime(); System.out.println(\"Sequential sum: \" + sum); System.out.println(\"Sequential execution time: \" + ((endTime - startTime) / 1_000_000) + \"ms\"); } public int sumSequentially(int[] array) { int sum = 0; for (int number : array) { sum += number; } return sum; } } 使用Fork/Join框架进行并行计算： import java.util.concurrent.ForkJoinPool; import java.util.concurrent.RecursiveTask; public class SumArrayExample { public static void main(String[] args) { SumArray sumArray = new SumArray(); int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9}; ForkJoinPool forkJoinPool = new ForkJoinPool(); long startTime = System.nanoTime(); int sum = forkJoinPool.invoke(sumArray.new ParallelSumTask(numbers, 0, numbers.length)); long endTime = System.nanoTime(); System.out.println(\"Parallel sum: \" + sum); System.out.println(\"Parallel execution time using Fork/Join: \" + ((endTime - startTime) / 1_000_000) + \"ms\"); } public class ParallelSumTask extends RecursiveTask { private final int[] array; private final int start; private final int end; public ParallelSumTask(int[] array, int start, int end) { this.array = array; this.start = start; this.end = end; } @Override protected Integer compute() { if (end - start 使用Java Stream并行流： public class SumArrayExample { public static void main(String[] args) { SumArray sumArray = new SumArray(); int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9}; long startTime = System.nanoTime(); int sum = Arrays.stream(numbers) .parallel() .sum(); long endTime = System.nanoTime(); System.out.println(\"Parallel sum using Java Stream: \" + sum); System.out.println(\"Parallel execution time using Java Stream: \" + ((endTime - startTime) / 1_000_000) + \"ms\"); } } 引用： 学习JUC高并发编程这一篇就够了（上篇）https://blog.csdn.net/apple_53947466/article/details/123656594 学习JUC高并发编程这一篇就够了（下篇）https://blog.csdn.net/apple_53947466/article/details/123664861 JUC基础【万字篇】https://blog.csdn.net/qq_43417581/article/details/127217919 Previous Java 集合 Next Java IO "},"6Java/Java/JavaIO.html":{"url":"6Java/Java/JavaIO.html","title":"Java IO","keywords":"","body":"I/O的定义 I/O 是 Input/Output 的首字母缩写，即输入/输出，它描述的是数据流动的过程。 输入/输出是相对而言的。下面将从两个角度出发来进一步理解 IO： 计算机结构的视角 根据冯·诺依曼结构，计算机分为五大部分，分别是：控制器、运算器、存储器、输入设备、输出设备。 输入设备（如鼠标键盘）和输出设备（如显示器）都属于外设（外部设备），而像磁盘、网卡这种既属于输入设备又属于输出设备。 从计算机的角度出发的话，操作系统将从输入设备读取到的数据写入到输出设备，这就是一次完整的 I/O 过程。 即 I/O 描述了计算机核心（CPU和内存）与外部设备之间的数据转移的过程。 应用程序的视角 我们都知道，应用程序作为一个文件保存在磁盘中，只有加载到内存中成为一个进程才能够运行。 为了确保操作系统的安全性和稳定性，操作系统会将内存分为 内核空间 和 用户空间，进行内存隔离。 而我们运行的应用程序都是运行在用户空间的，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等。也就是说，我们想要进行 I/O 操作，就必须依赖内核空间的能力。但是，用户空间的程序是无法直接访问内核空间的。 这时我们就需要通过发起系统调用请求操作系统帮忙完成，所以应用程序想要执行 I/O 操作的话，必须通过调用内核提供的 系统调用 进行间接访问。 我们在平常开发过程中接触最多的就是 磁盘 I/O（读写文件）和 网络 I/O（网络请求和响应） 从应用程序的角度出发的话，我们的应用程序对操作系统的内核发起 I/O 调用（系统调用），操作系统负责的内核执行具体的 I/O 操作。即强调的是通过向内核发起系统调用完成对 I/O 的间接访问。 上述过程换句话说即一次 I/O 操作实际上包含两个阶段： I/O 调用阶段：应用程序进程向内核发起系统调用 I/O 执行阶段：内核执行 I/O 操作并返回 内核等待 I/O 设备准备好数据 内核将数据从内核空间拷贝到用户空间 Linux中的5种IO模型 阻塞 I/O(Blocking I/O, BIO) 非阻塞 I/O(Non-blocking I/O, NIO) 多路复用 I/O (I/O Multiplexing) 信号驱动 I/O(Signal-driven I/O) 异步 I/O(Asynchronous I/O, AIO) 阻塞 I/O 阻塞IO是最常见的IO模型。 当发起一个IO操作时，比如读取数据，系统会调用read()函数。如果请求的数据没有准备好，此时进程会被挂起（blocked），进入等待状态。直到数据准备好，而且复制到应用进程的缓冲区，这时候才会返回。 从调用到返回，整个时间段都是阻塞的，所以被称为阻塞IO。 非阻塞 I/O 阻塞IO，还是比较浪费资源的，那么非阻塞IO就来了。 所谓非阻塞IO，是在调用IO操作时，如果缓冲区没有数据的话，直接返回一个错误码。应用进程需要不断轮询，来检查数据是否准备好。数据准备好了，就返回数据。 多路复用 I/O 虽然非阻塞IO相比阻塞IO，性能提升了很多，但是轮询过程中，还是有大量的系统调用，上下文切换的开销比较大。 那么，多路复用IO就来了。 多路指的是多个数据通道，复用指的是一个进程可以同时监控多个文件描述符（比如socket），当某个文件描述符状态发生变化（比如变得可读或可写），多路复用的函数将返回变化的文件描述符。 这样，在数据传输过程中，同一个进程中不同的任务都能被处理。特点是在数据传输过程中，进程能够同时处理多个任务，提高了程序的效率。 select、poll、epoll 等都是 I/O 多路复用的具体实现。 以select/poll为例，进程通过将一个或多个fd（全称是File Descriptor（文件描述符））传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以侦测多个fd是否处于就绪状态。当有fd就绪时，立即回调函数rollback，接下来就可以进行读取。 信号驱动 I/O 信号驱动式IO利用信号机制来进行数据传输。 进程首先告诉内核，当数据准备好时，请发送一个SIGIO信号。进程继续执行其他任务，等到收到信号后，再开始进行数据传输。 异步 I/O 异步IO是指当发起一个IO操作后，系统会立即返回。异步IO操作在后台进行数据传输，数据传输完成后，系统将通知进程。这样，在整个数据传输的过程中，进程都可以执行其他任务，不需要等待。 Java中的3种IO模型 阻塞 I/O(Blocking I/O, BIO) 非阻塞 I/O(Non-blocking I/O, NIO) 异步 I/O(Asynchronous I/O, AIO) 阻塞 I/O Java BIO就是Java的传统IO模型，对应了操作系统IO模型里的阻塞IO。 Java BIO相关的实现都位于java.io包下，其通信原理是客户端、服务端之间通过Socket套接字建立管道连接，然后从管道中获取对应的输入/输出流，最后利用输入/输出流对象实现发送/接收信息。 代码示例 BioServer： package com.walle.javaIO.bioDemo; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * BIO（同步阻塞IO）模式下的服务器端示例类。 * @Author wuyong * @Date 2024-04-04 */ public class BioServer { public static void main(String[] args) throws IOException { // 创建ServerSocket对象，并绑定到8888端口 ServerSocket server = new ServerSocket(8888); System.out.println(\"===========BIO服务端启动================\"); // 不断监听客户端连接，每个连接都创建一个新的线程处理 while (true) { // 接受客户端的Socket连接 Socket socket = server.accept(); new BioServerThread(socket).start(); // 启动处理线程 } } /** * 处理客户端请求的线程类。 * 使用同步阻塞IO方式读取客户端消息并回复。 */ static class BioServerThread extends Thread { // 客户端的Socket连接 private Socket socket; public BioServerThread(Socket socket) { this.socket = socket; } @Override public void run() { try { // 读取客户端发送的消息 InputStream inputStream = socket.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String msg; while ((msg = bufferedReader.readLine()) != null) { System.out.println(\"收到客户端消息：\" + msg); } // 向客户端发送消息 OutputStream outputStream = socket.getOutputStream(); PrintStream printStream = new PrintStream(outputStream); printStream.println(\"你好，吊毛！\"); printStream.flush(); // 刷新输出流，确保消息被发送 // 关闭Socket的输出流，表示服务端已发送完消息 socket.shutdownOutput(); } catch (IOException e) { e.printStackTrace(); } } } } BioClient： package com.walle.javaIO.bioDemo; import java.io.*; import java.net.Socket; import java.util.Arrays; import java.util.List; /** * BIO（同步阻塞IO）模式的客户端示例类。 * 该类用于创建一个简单的客户端，它会连接到服务器，发送一个消息，然后接收并打印服务器的响应。 * * @Author wuyong * @Date 2024-04-04 */ public class BioClient { public static void main(String[] args) throws IOException { List names = Arrays.asList(\"帅哥\", \"靓仔\", \"坤坤\"); // 循环创建多个客户端连接，每个连接发送不同的问候消息 for (String name : names) { // 创建Socket对象并连接到服务器 Socket socket = new Socket(\"127.0.0.1\", 8888); System.out.println(\"===========BIO客户端启动================\"); // 获取Socket的输出流，用于向服务器发送数据 OutputStream outputStream = socket.getOutputStream(); // 构建要发送的消息，并将其转换为字节流发送给服务器 String hello = \"你好，\" + name + \"!\"; outputStream.write(hello.getBytes()); // 清空输出流并关闭Socket的输出功能，准备读取输入流 outputStream.flush(); socket.shutdownOutput(); // 获取Socket的输入流，用于读取服务器返回的数据 InputStream inputStream = socket.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); // 读取并打印服务器发送的消息 String msg; while ((msg = bufferedReader.readLine()) != null) { System.out.println(\"收到服务端消息：\" + msg); } // 关闭输入流、输出流和Socket inputStream.close(); outputStream.close(); socket.close(); } } } 先启动BioServer，再启动BioClient，运行结果： ===========BIO服务端启动================ 收到客户端消息：你好，帅哥! 收到客户端消息：你好，靓仔! 收到客户端消息：你好，坤坤! ===========BIO客户端启动================ 收到服务端消息：你好，吊毛！ ===========BIO客户端启动================ 收到服务端消息：你好，吊毛！ ===========BIO客户端启动================ 收到服务端消息：你好，吊毛！ 在上述Java-BIO的通信过程中，如果客户端一直没有发送消息过来，服务端则会一直等待下去，从而服务端陷入阻塞状态。同理，由于客户端也一直在等待服务端的消息，如果服务端一直未响应消息回来，客户端也会陷入阻塞状态。 在BioServer定义了一个类BioServerThread，继承了Thread类，run方法里主要是通过socket和流来读取客户端的消息，以及发送消息给客户端，每处理一个客户端的Socket连接，就得新建一个线程。 同时，IO读写操作也是阻塞的，如果客户端一直没有发送消息过来，线程就会进入阻塞状态，一直等待下去。 在BioClient里，循环创建Socket，向服务端收发消息，客户端的读写也是阻塞的。 在这个Demo里就体现了BIO的两个特点： 一个客户端连接对应一个处理线程 读写操作都是阻塞的 毫无疑问，不管是创建太多线程，还是阻塞读写，都会浪费服务器的资源。 非阻塞 I/O 那么我们就进入Java的下一种IO模型——Java NIO，它对应操作系统IO模型中的多路复用IO，底层采用了epoll实现。 Java-NIO则是JDK1.4中新引入的API，它在BIO功能的基础上实现了非阻塞式的特性，其所有实现都位于java.nio包下。NIO是一种基于通道、面向缓冲区的IO操作，相较BIO而言，它能够更为高效的对数据进行读写操作，同时与原先的BIO使用方式也大有不同。 代码示例 NioServer： package com.walle.javaIO.nioDemo; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.util.Iterator; /** * NIO服务器示例，用于演示非阻塞I/O的服务器端实现。 * @Author wuyong * @Date 2024-04-04 */ public class NioServer { public static void main(String[] args) throws IOException { // 初始化选择器 Selector selector = Selector.open(); // 打开服务端套接字通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 绑定端口 serverSocketChannel.socket().bind(new InetSocketAddress(8888)); // 设置非阻塞模式 serverSocketChannel.configureBlocking(false); // 注册选择器，监听连接请求 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println(\"===========NIO服务端启动============\"); while (true) { // 超时等待客户端连接，避免无限阻塞 if (selector.select(1000) == 0) { System.out.println(\"===========NIO服务端超时等待============\"); continue; } // 处理就绪的客户端连接请求 Iterator iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) { SelectionKey key = iterator.next(); // 处理连接请求 if (key.isAcceptable()) { SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept(); socketChannel.configureBlocking(false); // 注册读事件，准备读取客户端数据 socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024)); System.out.println(\"成功连接客户端\"); } // 处理读事件，读取客户端数据 if (key.isReadable()) { SocketChannel socketChannel = (SocketChannel) key.channel(); try { ByteBuffer buffer = (ByteBuffer) key.attachment(); if (buffer == null) { buffer = ByteBuffer.allocate(1024); key.attach(buffer); } buffer.clear(); int len = socketChannel.read(buffer); if (len > 0) { buffer.flip(); String message = new String(buffer.array(), 0, len); System.out.println(\"收到客户端消息：\" + message); } else if (len NioClient： package com.walle.javaIO.nioDemo; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.SocketChannel; /** * NIO客户端示例。用于演示如何使用非阻塞I/O与服务器进行通信。 * @Author wuyong * @Date 2024-04-04 */ public class NioClient { public static void main(String[] args) throws IOException { // 创建SocketChannel并初始化连接地址 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 8888)); System.out.println(\"==============NIO客户端启动================\"); // 设置SocketChannel为非阻塞模式 socketChannel.configureBlocking(false); // 准备发送的消息 String hello=\"你好，靓仔！\"; ByteBuffer buffer = ByteBuffer.wrap(hello.getBytes()); // 向服务器发送消息 socketChannel.write(buffer); System.out.println(\"发送消息：\" + hello); buffer.clear(); // 注册Selector并设置监听读事件，为接收服务器响应做准备 socketChannel.register(Selector.open(), SelectionKey.OP_READ, buffer); while (true) { // 从服务器读取数据 if (socketChannel.read(buffer) > 0) { buffer.flip(); // 处理接收到的数据 String msg = new String(buffer.array(), 0, buffer.limit()); System.out.println(\"收到服务端消息：\" + msg); break; // 接收到消息后退出循环 } } // 关闭SocketChannel的输入流，准备关闭连接 socketChannel.shutdownInput(); // 关闭SocketChannel socketChannel.close(); } } 先运行NioServer，再运行NioClient，运行结果： ===========NIO服务端启动============ ===========NIO服务端超时等待============ ===========NIO服务端超时等待============ 成功连接客户端 收到客户端消息：你好，靓仔！ 向客户端发送消息：你好，坤坤！ ==============NIO客户端启动================ 发送消息：你好，靓仔！ 收到服务端消息：你好，坤坤！ 我们在这个案例里实现了一个比较简单的Java NIO 客户端服务端通信，里面有两个小的点需要注意，注册到选择器上的通道都必须要为非阻塞模型，同时通过缓冲区传输数据时，必须要调用flip()方法切换为读取模式。 Java-NIO中有三个核心概念：Buffer（缓冲区）、Channel（通道）、Selector（选择器）。 每个客户端连连接本质上对应着一个Channel通道，每个通道都有自己的Buffer缓冲区来进行读写，这些Channel被Selector选择器管理调度 Selector负责轮询所有已注册的Channel，监听到有事件发生，才提交给服务端线程处理，服务端线程不需要做任何阻塞等待，直接在Buffer里处理Channel事件的数据即可，处理完马上结束，或返回线程池供其他客户端事件继续使用。 通过Selector，服务端的一个Thread就可以处理多个客户端的请求 Buffer（缓冲区）就是饭店用来存放食材的储藏室，当服务员点餐时，需要从储藏室中取出食材进行制作。 Channel（通道）是用于传输数据的车道，就像饭店里的上菜窗口，可以快速把点好的菜品送到客人的桌上。 Selector（选择器）就是大堂经理，负责协调服务员、厨师和客人的配合和沟通，以保证整个就餐过程的效率和顺畅。 异步 I/O Java-AIO也被成为NIO2，它是在NIO的基础上，引入了新的异步通道的概念，并提供了异步文件通道和异步套接字的实现。 它们的主要区别就在于这个异步通道，见名知意：使用异步通道去进行IO操作时，所有操作都为异步非阻塞的，当调用read()/write()/accept()/connect()方法时，本质上都会交由操作系统去完成，比如要接收一个客户端的数据时，操作系统会先将通道中可读的数据先传入read()回调方法指定的缓冲区中，然后再主动通知Java程序去处理。 代码示例 AioServer： package com.walle.javaIO.aioDemo; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.AsynchronousChannelGroup; import java.nio.channels.AsynchronousServerSocketChannel; import java.nio.channels.AsynchronousSocketChannel; import java.nio.channels.CompletionHandler; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; /** * 异步IO（AIO）服务器示例类。 * 主要用于演示如何使用AIO方式实现一个简单的服务器，能够接收客户端连接并发送消息。 * * @Author wuyong * @Date 2024-04-04 */ public class AioServer { public static void main(String[] args) throws Exception { // 创建异步通道组，指定线程池大小，用于处理IO事件 AsynchronousChannelGroup group = AsynchronousChannelGroup.withFixedThreadPool(10, Executors.defaultThreadFactory()); // 创建异步服务器Socket通道，并绑定到指定端口 AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(group).bind(new InetSocketAddress(8888)); System.out.println(\"=============AIO服务端启动=========\"); // 异步等待接收客户端连接请求 server.accept(null, new CompletionHandler() { // 用于读取数据的ByteBuffer final ByteBuffer buffer = ByteBuffer.allocate(1024); @Override public void completed(AsynchronousSocketChannel channel, Object attachment) { System.out.println(\"客户端连接成功\"); try { buffer.clear(); // 异步读取客户端发送的数据 channel.read(buffer, null, new CompletionHandler() { @Override public void completed(Integer len, Object attachment) { buffer.flip(); // 将读取到的数据转换为字符串 String message = new String(buffer.array(), 0, len); System.out.println(\"收到客户端消息：\" + message); // 异步向客户端发送消息 channel.write(ByteBuffer.wrap((\"你好，阿坤！\").getBytes()), null, new CompletionHandler() { @Override public void completed(Integer result, Object attachment) { // 关闭通道的输出流 try { channel.shutdownOutput(); } catch (IOException e) { e.printStackTrace(); } } @Override public void failed(Throwable exc, Object attachment) { exc.printStackTrace(); // 关闭通道 try { channel.close(); } catch (IOException e) { e.printStackTrace(); } } }); } @Override public void failed(Throwable exc, Object attachment) { exc.printStackTrace(); // 关闭通道 try { channel.close(); } catch (IOException e) { e.printStackTrace(); } } }); } catch (Exception e) { e.printStackTrace(); } // 继续等待下一个客户端连接 server.accept(null, this); } @Override public void failed(Throwable exc, Object attachment) { exc.printStackTrace(); // 继续等待下一个客户端连接 server.accept(null, this); } }); // 等待异步通道组处理所有连接，直到程序被终止 group.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS); } } AioClient： package com.walle.javaIO.aioDemo; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.AsynchronousSocketChannel; import java.nio.channels.CompletionHandler; /** * 异步IO客户端示例类 * 主要用于演示如何使用异步方式与服务器进行通信。 * * @Author wuyong * @Date 2024-04-04 */ public class AioClient { public static void main(String[] args) throws Exception { // 创建异步Socket通道 AsynchronousSocketChannel client = AsynchronousSocketChannel.open(); // 创建ByteBuffer final ByteBuffer buffer = ByteBuffer.wrap((\"你好，靓仔！\").getBytes()); // 异步连接服务器 client.connect(new InetSocketAddress(\"127.0.0.1\", 8888), null, new CompletionHandler() { // 当连接操作完成时调用此方法 @Override public void completed(Void result, Object attachment) { // 异步发送消息给服务器 client.write(buffer, null, new CompletionHandler() { // 创建ByteBuffer final ByteBuffer readBuffer = ByteBuffer.allocate(1024); // 当消息写入完成时调用此方法 @Override public void completed(Integer result, Object attachment) { // 准备读取服务器响应 readBuffer.clear(); // 异步读取数据 client.read(readBuffer, null, new CompletionHandler() { // 当数据读取完成时调用此方法 @Override public void completed(Integer result, Object attachment) { // 处理接收到的数据 readBuffer.flip(); String msg = new String(readBuffer.array(), 0, result); System.out.println(\"收到服务端消息：\" + msg); } // 当读取操作失败时调用此方法 @Override public void failed(Throwable exc, Object attachment) { // 处理异常并关闭连接 exc.printStackTrace(); try { client.close(); } catch (IOException e) { e.printStackTrace(); } } }); } // 当写操作失败时调用此方法 @Override public void failed(Throwable exc, Object attachment) { // 处理异常并关闭连接 exc.printStackTrace(); try { client.close(); } catch (IOException e) { e.printStackTrace(); } } }); } // 当连接操作失败时调用此方法 @Override public void failed(Throwable exc, Object attachment) { // 处理异常并关闭连接 exc.printStackTrace(); try { client.close(); } catch (IOException e) { e.printStackTrace(); } } }); // 等待一段时间以确保连接操作完成 Thread.sleep(1000); // 关闭输入流和Socket通道 client.shutdownInput(); client.close(); } } 先运行AioServer，再运行AioClient，运行结果： =============AIO服务端启动========= 客户端连接成功 收到客户端消息：你好，靓仔！ 收到服务端消息：你好，阿坤！ 可以看到，所有的操作都是异步进行，通过completed接收异步回调，通过failed接收错误回调。 而且我们发现，相较于之前的NIO而言，AIO其中少了Selector选择器这个核心组件，选择器在NIO中充当了协调者的角色。 但在Java-AIO中，类似的角色直接由操作系统担当，而且不是采用轮询的方式监听IO事件，而是采用一种类似于“订阅-通知”的模式。 在AIO中，所有创建的通道都会直接在OS上注册监听，当出现IO请求时，会先由操作系统接收、准备、拷贝好数据，然后再通知监听对应通道的程序处理数据。 Java-AIO这种异步非阻塞式IO也是由操作系统进行支持的，在Windows系统中提供了一种异步IO技术：IOCP(I/O Completion Port，所以Windows下的Java-AIO则是依赖于这种机制实现。不过在Linux系统中由于没有这种异步IO技术，所以Java-AIO在Linux环境中使用的还是epoll这种多路复用技术进行模拟实现的。 因为Linux的异步IO技术实际上不太成熟，所以Java-AIO的实际应用并不是太多，比如大名鼎鼎的网络通信框架Netty就没有采用Java-AIO，而是使用Java-NIO，在代码层面，自行实现异步。 小结 Java的三种IO机制，它们的特点，我们直接看下图： 我们也发现，虽然Java-NIO、Java-AIO，在性能上比Java-BIO要强很多，但是可以看到，写法上一个比一个难搞，不过好在基本也没人直接用Java-NIO、Java-AIO，如果要进行网络通信，一般都会采用Netty，它对原生的Java-NIO进行了封装优化，接下来，我们会继续走近Netty，敬请期待。 Netty 未完待续... 引用： Java IO模型详解 https://blog.csdn.net/m0_53067943/article/details/128957719 一顿饭的事儿，搞懂了Linux5种IO模型 https://fighter3.blog.csdn.net/article/details/130571808 Java 3种IO模型，一次搞懂 https://fighter3.blog.csdn.net/article/details/130614023 Previous Java 并发 Next Java8 新特性 "},"6Java/Java/Java8新特性.html":{"url":"6Java/Java/Java8新特性.html","title":"Java8 新特性","keywords":"","body":"Lambda表达式 语法格式：() -> {} 函数式接口 方法引用 Stream流 创建流 单列集合 数组 双列集合 中间操作 filter map,flatMap distinct sorted limit,skip 终止操作 forEach count,min,max collect anyMatch,allMatch,noneMatch findAny,finFirst reduce Optional类 Optional.ofNullable(T t)：若 t 不为 null，创建 Optional 实例，否则空实例 isPresent()：判断是否包含某值 新时间日期API LocalDate LocalTime LocalDateTime Previous Java IO Next JVM "},"6Java/JVM/JVM.html":{"url":"6Java/JVM/JVM.html","title":"JVM","keywords":"","body":"JVM Previous Java8 新特性 Next 设计模式 "},"6Java/Design Pattern/设计模式.html":{"url":"6Java/Design Pattern/设计模式.html","title":"设计模式","keywords":"","body":"面向对象设计原则 7种面向对象设计原则，其中前5条是强约束性的建议都做到，后2条尽量做到即可。 类图-关联关系 耦合度大小排序：泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖 泛化：指的是继承关系，表达一般和特殊。符号：空心三角箭头的实线，箭头指向父类。（注：UML中只有泛化，继承是开发角度的描述。） 实现：指的是类与接口的关系，表达类实现了接口的特征行为。符号：带三角箭头的虚线，箭头指向接口。 组合：指的是整体与部分的关系, 但部分不能离开整体而单独存在。符号：带实心菱形的实线，菱形指向整体。 聚合：指的是整体和部分关系，且部分可以离开整体而单独存在。符号：空心菱形的实心线，菱形指向整体。 关联：指的是类和类的关系，表达一个类知道另一个类的属性和方法。符号：带普通箭头（或实心三角形箭头）的实心线。 依赖：指的是使用的关系, 即一个类的实现需要另一个类的协助, 所以要尽量不使用双向的互相依赖。符号：带箭头的虚线，指向被依赖的类。 Java代码示例： 泛化：is-a // 接口 public interface Printable { void printDocument(); } // 实现类 public class PDFPrinter implements Printable { @Override public void printDocument() { System.out.println(\"Printing the document as PDF...\"); } } 实现：is-a // 接口 public interface Printable { void printDocument(); } // 实现类 public class PDFPrinter implements Printable { @Override public void printDocument() { System.out.println(\"Printing the document as PDF...\"); } } 组合：has-a // 整体类 public class Computer { private CPU cpu; public Computer() { this.cpu = new CPU(); } public void start() { cpu.boot(); } // CPU 类在 Computer 类中被组合，Computer 销毁时 CPU 也会被清理 private class CPU { public void boot() { System.out.println(\"CPU booted.\"); } } } 聚合：has-a // 整体类 public class Library { private List books; public Library() { this.books = new ArrayList<>(); } public void addBook(Book book) { books.add(book); } // Book 类在 Library 中被聚合，Library 销毁时 Book 可以独立存在 public static class Book {} } 关联：has-a public class Student { private Teacher teacher; public Student(Teacher t) { this.teacher = t; } public void setTeacher(Teacher teacher) { this.teacher = teacher; } public Teacher getTeacher() { return teacher; } // Teacher 类与 Student 类关联，彼此独立，生命周期不互相影响 public static class Teacher {} } 依赖：use-a public class Formatter { public String formatMessage(Message message) { return \"Formatted: \" + message.getMessageContent(); } // Formatter 类依赖 Message 类，但不持有其实例 public static class Message { private String messageContent; public Message(String content) { this.messageContent = content; } public String getMessageContent() { return messageContent; } } } 类图-表示方法 从上到下分为3部分：类名、属性、方法。 符号含义：+ public、- private、# protected 设计模式 23种 VS 24种 到底几种？23种！即GOF的23种设计模式。还有1个模式：简单工厂模式，确实在后续应用比较多，但在1995年未列入GOF。 本节列举24种设计模式，其中创建型模式6种、结构型模式7种、行为型模式11种。 每个模式从3个角度进行分析：定义、UML类图、应用 创建型模式 1.单例模式（Singleton） 定义：确保一个类只有一个实例，并提供一个全局访问点。 UML类图： 应用： 2.原型模式（Prototype） 定义：通过复制现有对象来创建新对象。 UML类图： 应用： 3.简单工厂模式（Static Factory Method Pattern） 定义：定义一个工厂类，根据传入不同参数返回不同实例。 UML类图： 应用： 4.工厂方法模式（Factory Method） 定义：定义一个创建对象的接口，让子类决定实例化哪个类。 UML类图： 应用： 5.抽象工厂模式（Abstract Factory） 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类。 UML类图： 应用： 6.建造者模式（Builder） 定义：分步骤构建复杂对象，隐藏内部构造细节。 UML类图： 应用： 结构型模式 1.适配器模式（Adapter） 定义：将一个类的接口转换成客户端所期望的另一个接口。 应用： 2.桥接模式（Bridge） 定义：将抽象部分与它的实现部分分离。 UML类图： 应用： 3.组合模式（Composite） 定义：将对象组合成树形结构来表现“整体-部分”层次结构。 UML类图： 应用： 4.装饰器模式（Decorator） 定义：动态地给对象添加额外的职责。 UML类图： 应用： 5.外观模式（Facade） 定义：为子系统中的一组接口提供一个统一的高层接口。 UML类图： 应用： 6.享元模式（Flyweight） 定义：通过共享已经存在的对象来减少内存消耗。 UML类图： 应用： 7.代理模式（Proxy） 定义：为其他对象提供一种代理以控制对这个对象的访问。 UML类图： 应用： 行为型模式 1.责任链模式（Chain of Responsibility） 定义：将请求沿着对象链传递直到被处理。 UML类图： 应用： 2.命令模式（Command） 定义：将请求封装成一个对象。 UML类图： 应用： 3.解释器模式（Interpreter） 定义：给定一个语言，定义它的文法表示，并提供一个解释器来解释该语言中的句子。 UML类图： 应用： 4.迭代器模式（Iterator） 定义：提供遍历元素的统一接口，隐藏集合内部表示。 UML类图： 应用： 5.中介者模式（Mediator） 定义：用一个中介对象来封装一系列对象的交互。 UML类图： 应用： 6.备忘录模式（Memento） 定义：在不破坏封装性的前提下，保存和恢复对象状态。 UML类图： 应用： 7.观察者模式（Observer） 定义：当对象状态改变时自动通知订阅者。 UML类图： 应用： 8.状态模式（State） 定义：允许对象在其内部状态改变时改变行为。 UML类图： 应用： 9.策略模式（Strategy） 定义：定义一系列算法，将每个算法封装起来，并使它们可以相互替换。 UML类图： 应用： 10.模板方法模式（Template Method） 定义：定义操作的框架，允许子类重写特定步骤。 UML类图： 应用： 11.访问者模式（Visitor） 定义：在不改变数据结构的前提下，定义作用于这些数据结构元素的新操作。 UML类图： 应用： 引用： 一文掌握设计模式（定义+UML类图+应用）https://www.cnblogs.com/dennyzhangdd/p/17462931.html Previous JVM "},"7Database/MySQL/MySQL.html":{"url":"7Database/MySQL/MySQL.html","title":"MySQL","keywords":"","body":"MySQL "},"7Database/Redis/Redis基础.html":{"url":"7Database/Redis/Redis基础.html","title":"Redis基础","keywords":"","body":"Redis基础 基本数据类型 1. String 字符串 2. LIst 列表 3. Set 集合 4. SortedSet 有序集合 5. Hash 哈希 高级数据类型 1. Stream 消息队列(MQ) 生产信息 消费消息 2. Geospatial 地理空间 经度 纬度 3. HyperLogLog 4. Bitmap 位图 5. Bitfield 位域 高级内容 1. 发布订阅 发布消息 订阅消息 消息无法持久化，通过Stream消息队列实现持久化 2. 持久化 RDB：快照 redis.conf配置文件 save命令 bgsave命令 AOF：追加文件 redis.conf配置文件 3. 事务 与mysql中的事务概念不同 与shell脚本中执行批量命令的概念类似 4. 主从模式 5. 哨兵模式 高可用部署 Redis 集群（一主两从三哨兵） 整体架构 搭建步骤 使用3台服务器，分别安装 redis，并进行防火墙设置 ip port role 192.168.180.197 6379 master 192.168.180.198 6380 slave 192.168.180.199 6381 slave 配置主节点（192.168.180.197）： 修改主节点 redis.conf 配置文件： # 主节点配置 bind 192.168.180.197 # 绑定主节点IP地址 port 6379 # 主节点端口号 daemonize yes # 以守护进程模式运行 logfile \"/var/log/redis/redis.log\" # 日志文件路径 save 900 1 save 300 10 save 60 10000 配置从节点（192.168.180.198、192.168.180.199）： 修改从节点 redis.conf 配置文件：replicaof 192.168.180.197 6379 # 从节点配置 bind 192.168.180.198 (或者192.168.180.199) # 绑定从节点IP地址 port 6380 (或者6381) # 从节点端口号 daemonize yes # 以守护进程模式运行 logfile \"/var/log/redis/redis.log\" # 日志文件路径 save 900 1 save 300 10 save 60 10000 replicaof 192.168.180.197 6379 # 设置主从关系 配置哨兵节点： 在每个哨兵节点（每台服务器）上创建 sentinel.conf 配置文件 并添加以下内容：sentinel monitor mymaster 192.168.180.197 6379 2 # 哨兵节点配置 port 26379 (或26380)(或26381) # 哨兵节点监听端口 daemonize yes # 以守护进程模式运行 logfile \"/var/log/redis/sentinel.log\" # 日志文件路径 sentinel monitor mymaster 192.168.180.197 6379 2 # 监控主节点，指定当有2台哨兵认为主机挂了，则对主机进行切换 sentinel down-after-milliseconds mymaster 5000 # 故障判定时间 sentinel failover-timeout mymaster 60000 # 故障转移超时时间 sentinel parallel-syncs mymaster 1 # 同步复制的数量 在发生主节点故障时，哨兵节点会检测到并触发故障转移。其中一个从节点将被选举为新的主节点，并且哨兵节点会更新配置文件以反映这一变化。因此，即使出现主从节点切换，哨兵节点仍然可以起到监控和自动故障转移的作用。 Next Redis应用 "},"7Database/Redis/Redis应用.html":{"url":"7Database/Redis/Redis应用.html","title":"Redis应用","keywords":"","body":"Redis应用 在Spring Boot中使用Redis作为缓存后端并通过注解方式实现缓存功能，首先需确保已配置好Redis并添加对应起步依赖。以下是一个简化的示例，演示如何在Spring Boot中利用Redis缓存注解 (@Cacheable, @CachePut, @CacheEvict)： 首先，在pom.xml中引入Spring Boot Data Redis的起步依赖： Xml org.springframework.boot spring-boot-starter-data-redis 接着，在application.properties或application.yml中配置Redis连接： Properties spring.redis.host=localhost spring.redis.port=6379 创建一个自定义Redis缓存配置类： Java import org.springframework.cache.CacheManager; import org.springframework.cache.annotation.CachingConfigurerSupport; import org.springframework.cache.interceptor.CacheErrorHandler; import org.springframework.cache.interceptor.CacheResolver; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.cache.RedisCacheConfiguration; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; @Configuration public class RedisCacheConfig extends CachingConfigurerSupport { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory factory) { RedisTemplate template = new RedisTemplate<>(); template.setConnectionFactory(factory); // 添加序列化器等配置... return template; } @Bean public CacheManager cacheManager(RedisConnectionFactory factory) { RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() // 设置缓存过期策略等配置... .entryTtl(Duration.ofMinutes(30)); // 设置默认缓存有效期30分钟 return RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); } } 在服务接口中使用缓存注解： Java import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; @Service public class UserService { // 假设有方法从数据库获取用户信息 @Cacheable(value = \"users\", key = \"#id\") public User getUserById(Long id) { // 这里实际上会调用DAO或者其他方法从数据库获取用户信息 // 实际业务代码省略... // 这里仅模拟从数据库获取用户，并假设User是从数据库查询得到的对象 User user = new User(id, \"username\", \"email\"); return user; } // 其他如@CachePut 和 @CacheEvict 的用法类似，此处不再详述 } 在这个示例中： @Cacheable(\"users\") 表明缓存区域名为“users”。 key=\"#id\" 表示缓存键值由方法参数id决定。 当调用getUserById方法时，系统会首先在Redis中查找键为方法参数id的缓存项，如果存在则直接返回缓存的数据，否则执行方法体并将返回结果保存到缓存中。此外，可根据实际情况调整其他缓存策略和高级配置。 Previous Redis基础 Next MongoDB "},"7Database/MongoDB/MongoDB.html":{"url":"7Database/MongoDB/MongoDB.html","title":"MongoDB","keywords":"","body":"MongoDB Previous Redis应用 Next ES "},"7Database/ES/ES.html":{"url":"7Database/ES/ES.html","title":"ES","keywords":"","body":"ES Previous MongoDB "},"8Spring/IOC.html":{"url":"8Spring/IOC.html","title":"IOC","keywords":"","body":"IOC Next AOP "},"8Spring/AOP.html":{"url":"8Spring/AOP.html","title":"AOP","keywords":"","body":"AOP Previous IOC Next MVC "},"8Spring/MVC.html":{"url":"8Spring/MVC.html","title":"MVC","keywords":"","body":"MVC Previous AOP "},"9SpringBoot/Boot.html":{"url":"9SpringBoot/Boot.html","title":"Boot","keywords":"","body":"Boot Next Mybatis "},"9SpringBoot/Mybatis.html":{"url":"9SpringBoot/Mybatis.html","title":"Mybatis","keywords":"","body":"Mybatis Previous Boot Next Jpa "},"9SpringBoot/Jpa.html":{"url":"9SpringBoot/Jpa.html","title":"Jpa","keywords":"","body":"Jpa Previous Mybatis "},"10SpringCloud/Netflix/Eureka.html":{"url":"10SpringCloud/Netflix/Eureka.html","title":"Eureka","keywords":"","body":"Eureka "},"10SpringCloud/Alibaba/Nacos.html":{"url":"10SpringCloud/Alibaba/Nacos.html","title":"Nacos","keywords":"","body":"Nacos "},"10SpringCloud/MQ/消息队列.html":{"url":"10SpringCloud/MQ/消息队列.html","title":"消息队列","keywords":"","body":"消息队列 "},"98SpringBootCloud/RBAC.html":{"url":"98SpringBootCloud/RBAC.html","title":"RBAC","keywords":"","body":"RBAC Next SSO "},"98SpringBootCloud/SSO.html":{"url":"98SpringBootCloud/SSO.html","title":"SSO","keywords":"","body":"SSO Previous RBAC Next OAuth2 "},"98SpringBootCloud/OAuth2.html":{"url":"98SpringBootCloud/OAuth2.html","title":"OAuth2","keywords":"","body":"OAuth2 Previous SSO Next FileUpload "},"98SpringBootCloud/FileUpload.html":{"url":"98SpringBootCloud/FileUpload.html","title":"FileUpload","keywords":"","body":"FileUpload Previous OAuth2 Next VideoPlay "},"98SpringBootCloud/VideoPlay.html":{"url":"98SpringBootCloud/VideoPlay.html","title":"VideoPlay","keywords":"","body":"VideoPlay Previous FileUpload Next WebSocket "},"98SpringBootCloud/WebSocket.html":{"url":"98SpringBootCloud/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket Previous VideoPlay Next WXPay "},"98SpringBootCloud/WXPay.html":{"url":"98SpringBootCloud/WXPay.html","title":"WXPay","keywords":"","body":"WXPay Previous WebSocket Next WXLogin "},"98SpringBootCloud/WXLogin.html":{"url":"98SpringBootCloud/WXLogin.html","title":"WXLogin","keywords":"","body":"WXLogin Previous WXPay Next Activiti7 "},"98SpringBootCloud/Activiti7.html":{"url":"98SpringBootCloud/Activiti7.html","title":"Activiti7","keywords":"","body":"Activiti7 Previous WXLogin Next Excel "},"98SpringBootCloud/Excel.html":{"url":"98SpringBootCloud/Excel.html","title":"Excel","keywords":"","body":"Excel Previous Activiti7 "},"99WebStack/nav.html":{"url":"99WebStack/nav.html","title":"WebStack","keywords":"","body":"常用搜索 Google 全球最大的搜索引擎 Baidu 中国最大的搜索引擎 Bing 微软公司的搜索引擎 YouTube 全球视频分享平台 哔哩哔哩 中国视频分享平台 LeetCode 在线编程挑战平台 Hello Algo 在线算法学习资源 Java API Java SE API 官方文档 AI工具 通义千问 阿里巴巴人工智能模型 ChatGPT Open AI 交互式聊天平台 ai-bot AI 工具集 Gemini Google AI 交互式聊天平台 Kimi Moonshot 帮你看更大的世界 技术社区 Stack Overflow 开发者问答社区 CSDN 开发者社区CSDN 博客园 开发者社区博客园 在线教程 W3school Web开发教程资源 W3Cschool 各种教程资源 菜鸟教程 各种教程资源 后端开发 Spring Spring官方网站 MyBatis Mybatis官方网站 MyBatis Plus Mybatis Plus官方网站 前端开发 Bootstrap 前端开发框架 Vue 渐进式JavaScript框架 Element-UI 基于 Vue 2.0 的桌面端组件库 代码托管 GitHub 全球最大的开源软件托管平台 Gitee 中国最大的开源软件托管平台 GitLab 一体化DevOps平台 官方仓库 MVN Repository Maven官方仓库 NPMJS NPM官方仓库 Docker Hub Docker镜像官方仓库 在线工具 菜鸟工具 菜鸟教程的在线工具 开源中国工具 开源中国的在线工具 Tool工具箱 程序员的工具箱 推荐资源 pdai.tech Java 全栈知识体系 简言之 慢慢来，比较快！ IntelliJ-IDEA-Tutorial IDEA 教程 Play with Docker 在线的Docker容器实验平台 其他资源 "}}