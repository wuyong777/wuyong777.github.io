# 阅读指南

## 进程、线程、协程、同步、异步、阻塞、非阻塞、并发、并行、串行

1. **进程**：
   - 进程是操作系统中资源分配和调度的基本单位，代表着系统中运行的一个程序实例。
   - 每个进程都有独立的内存空间和其他系统资源。
   - 不同的进程之间相互隔离，通过进程间通信（IPC）机制进行信息交互。
2. **线程**：
   - 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程内部的一个独立执行流。
   - 一个进程中可以包含多个线程。这些线程共享进程的内存空间和其他资源，因此创建和切换线程的开销小于进程。
   - 多线程可以实现进程内部的并发执行，提高CPU利用率。
3. **协程**：
   - 协程是一种用户态的轻量级线程实现，也称作协作式多任务。
   - 它不同于操作系统调度的线程，协程的调度完全由用户程序控制。
   - 协程可以在函数调用时保存上下文并在适当时候恢复执行，允许在单个线程中模拟出多任务效果，且没有线程切换的开销。
4. **同步**：
   - 同步指的是一个操作完成后才会执行下一个操作。
   - 比如在编程中调用一个函数，直到该函数返回结果后，后续代码才会继续执行。
   - 同步执行不会立即返回控制权，而是等待任务完成。
5. **异步**：
   - 异步则是指发起一个操作后，无需等待该操作完成即可继续执行后续代码。
   - 操作结果通过回调，或者通过事件等机制通知调用者。
   - 这种模式下，程序不会阻塞等待某个操作结束，即调用发出后不必等待响应就可以去做别的事情。
6. **阻塞**：
   - 阻塞是指在执行某个操作（如I/O请求）时，调用线程或进程会暂停执行，直到该操作完成。
   - 在此期间，操作系统可能将CPU时间片分配给其他可执行的线程或进程。
7. **非阻塞**：
   - 非阻塞操作则是指调用发出后，调用者不会被挂起，而是立即返回一个状态（如“未准备好”）。
   - 然后调用者可以选择轮询检查操作是否完成，或者通过事件通知机制得知操作完成。
8. **并发**：
   - 并发是指在一段时间内多个任务交替执行，从宏观上看似乎同时发生，但实际上由于CPU时间片轮转，微观上并非真正的同时执行。
   - 并发强调的是多个任务在执行时间上的重叠。
9. **并行**：
   - 并行指两个或多个任务在同一时刻真正地同时执行，尤其在多核或多处理器环境中，每个核心可以独立执行任务，实现物理上的同时处理。
   - 并行强调的是在硬件层面上的真正同时执行。
10. **串行**：
    - 串行是指任务按照严格的顺序执行，一个任务执行完毕后下一个任务才能开始。
    - 在单核系统中，如果没有并发机制的话，所有任务只能串行执行。
    - 即使在多核系统中，若没有充分利用多核特性，也可能表现为串行执行。

## 操作系统中常见的锁类型

**互斥锁（Mutexes）**

- 最基本的同步原语之一，确保任何时候只有一个线程可以访问临界区。
- 当锁被占用时，请求锁的线程会被操作系统挂起（放入等待队列），直至锁释放后重新调度。
- 高开销主要在于上下文切换和线程调度。

**自旋锁（Spin Locks）**

- 同样保证互斥访问，但在尝试获取锁时，线程不放弃CPU，而是在原地循环等待（自旋）。
- 适用于锁保持时间极短且线程调度开销较大的环境，如低级别的内核代码。
- 若锁持有时间过长，自旋锁可能导致CPU使用率过高和不公平的调度。

**读写锁（Read-Write Locks）**

- 允许任意数量的读取者同时访问共享资源，但写入者会独占资源，阻止新的读取者和写入者。
- 在读多写少的情况下可以显著提高并发性能。

**悲观锁与乐观锁**

- **悲观锁**：持保守态度，认为并发访问必然会导致冲突，所以在访问资源之前先获取锁。
- **乐观锁**：相对乐观，认为冲突很少发生，一般不显式加锁，在更新数据时检测是否有冲突发生，如有则重试或回滚，常通过原子操作如CAS来实现。

**信号量（Semaphores）**

- 信号量不仅限于二元状态，可以是一个整数值，表示可供使用的资源数量。
- 当请求资源的线程发现信号量值小于请求值时，同样会被阻塞。
- 用于控制对有限资源的并发访问，如数据库连接池或文件句柄等。

**条件变量（Condition Variables）**

- 结合互斥锁使用，条件变量提供了一种基于条件的同步机制。
- 线程可以在条件不满足时释放锁并进入等待状态，当条件满足时被其他线程唤醒。

## Java中常见的锁类型

![](img/java-lock.png)

## 操作系统中的五种IO模型

- **阻塞 I/O**`(Blocking I/O, BIO)`
- **非阻塞 I/O**`(Non-blocking I/O, NIO)`
- **I/O 多路复用**`(I/O Multiplexing)`
- **信号驱动 I/O**`(Signal-driven I/O)`
- **异步 I/O**`(Asynchronous I/O, AIO)`

## Java中的三种IO模型

- **阻塞 I/O**`(Blocking I/O, BIO)`
- **非阻塞 I/O**`(Non-blocking I/O, NIO)`
- **异步 I/O**`(Asynchronous I/O, AIO)`

